{"ast":null,"code":"import { __decorate, __param } from 'tslib';\nimport { Inject, NgZone, ElementRef, HostBinding, ViewChild, Component, ChangeDetectionStrategy, NgModule } from '@angular/core';\nimport { WINDOW, ANIMATION_FRAME } from '@ng-web-apis/common';\nimport { POLLING_TIME, tuiZonefree, getClosestElement, inRange, px, getClosestFocusable, setNativeFocused, TuiDestroyService, TuiDropdownHostComponent, AbstractTuiPortalHostComponent, tuiPure, TuiActiveZoneModule, TuiOverscrollModule } from '@taiga-ui/cdk';\nimport { tuiDropdownAnimation } from '@taiga-ui/core/animations';\nimport { DEFAULT_MARGIN, DEFAULT_MAX_WIDTH } from '@taiga-ui/core/constants';\nimport { TUI_DROPDOWN_DIRECTIVE, TUI_ANIMATION_OPTIONS } from '@taiga-ui/core/tokens';\nimport { getScreenWidth } from '@taiga-ui/core/utils/dom';\nimport { merge, fromEvent, Observable } from 'rxjs';\nimport { throttleTime, takeUntil } from 'rxjs/operators';\nimport { TuiScrollbarModule } from '@taiga-ui/core/components/scrollbar';\nimport { TuiModeModule } from '@taiga-ui/core/directives/mode';\nimport { PolymorpheusModule } from '@tinkoff/ng-polymorpheus';\n/**\n *  This component is used to show template in a portal using default style of white rounded box with a shadow\n */\n// @bad TODO: OnPush\n// Ambient type cannot be used without dynamic https://github.com/angular/angular/issues/23395\n// @dynamic\n\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from '@taiga-ui/cdk';\nimport * as ɵngcc2 from '@taiga-ui/core/directives/mode';\nimport * as ɵngcc3 from '@taiga-ui/core/components/scrollbar';\nimport * as ɵngcc4 from '@tinkoff/ng-polymorpheus';\nimport * as ɵngcc5 from 'rxjs';\nconst _c0 = [\"content\"];\nlet TuiDropdownBoxComponent = /*#__PURE__*/(() => {\n  let TuiDropdownBoxComponent = class TuiDropdownBoxComponent {\n    constructor(destroy$, ngZone, directive, windowRef, elementRef, portalHost, options, animationFrame$) {\n      this.directive = directive;\n      this.windowRef = windowRef;\n      this.elementRef = elementRef;\n      this.portalHost = portalHost;\n      this.options = options;\n      this.animationTop = Object.assign({\n        value: \"fadeInTop\"\n        /* FadeInTop */\n\n      }, this.options);\n      this.animationBottom = Object.assign({\n        value: \"fadeInBottom\"\n        /* FadeInBottom */\n\n      }, this.options);\n      /**\n       * Is previous position on top (to prevent jumping up and down on scroll)\n       */\n\n      this.prevDirectionIsTop = false;\n      merge(animationFrame$.pipe(throttleTime(POLLING_TIME)), this.directive.refresh$, fromEvent(this.windowRef, 'resize')).pipe(tuiZonefree(ngZone), takeUntil(destroy$)).subscribe(() => {\n        this.calculatePositionAndSize();\n      });\n    }\n\n    get overscroll() {\n      return this.inModal ? 'all' : 'scroll';\n    }\n\n    getContext(context, activeZone) {\n      return Object.assign(Object.assign({}, context), {\n        activeZone\n      });\n    }\n\n    ngAfterViewChecked() {\n      this.calculatePositionAndSize();\n    }\n\n    onTopFocus() {\n      this.moveFocusOutside(true);\n    }\n\n    onBottomFocus() {\n      this.moveFocusOutside(false);\n    }\n\n    get inModal() {\n      // @awful TODO: get rid of component tag name dependency\n      return !!getClosestElement(this.directive.host, 'tui-dialog-host');\n    }\n\n    calculatePositionAndSize() {\n      const {\n        clientRect\n      } = this.directive;\n      const {\n        style\n      } = this.elementRef.nativeElement;\n      const hostRect = this.directive.fixed ? this.portalHost.fixedPositionOffset() : this.portalHost.clientRect;\n      style.position = this.directive.fixed ? 'fixed' : 'absolute';\n      this.calculateVerticalPosition(style, clientRect, hostRect);\n      this.calculateHorizontalPosition(style, clientRect, hostRect);\n      this.calculateWidth(style, clientRect);\n    }\n\n    getFinalAlign(style, directiveRect) {\n      const dropdownRect = this.elementRef.nativeElement.getBoundingClientRect();\n      const dropdownWidth = this.elementRef.nativeElement.offsetWidth;\n      const screenWidth = getScreenWidth(this.windowRef.document);\n      const isDropdownSizeHypotheticallyFitsViewport = directiveRect.left + dropdownWidth < screenWidth || directiveRect.right - dropdownWidth > 0;\n      const isDropdownSizeActuallyFitsViewport = dropdownRect.right <= screenWidth && dropdownRect.left >= 0;\n      let finalAlign = this.directive.align;\n\n      switch (this.directive.align) {\n        case 'left':\n          if (isDropdownSizeHypotheticallyFitsViewport && dropdownRect.right > screenWidth) {\n            finalAlign = 'right';\n          }\n\n          break;\n\n        case 'right':\n          if (isDropdownSizeHypotheticallyFitsViewport && dropdownRect.left < 0) {\n            finalAlign = 'left';\n          }\n\n          break;\n      }\n\n      if (style.right === 'auto' && isDropdownSizeActuallyFitsViewport) {\n        finalAlign = 'left';\n      }\n\n      if (style.left === 'auto' && isDropdownSizeActuallyFitsViewport) {\n        finalAlign = 'right';\n      }\n\n      return finalAlign;\n    }\n    /**\n     * Calculates horizontal position\n     *\n     * @param style dropdownBox elementRef styles object\n     * @param directiveRect ClientRect of hosting directive\n     * @param hostRect ClientRect of  portal host\n     */\n\n\n    calculateHorizontalPosition(style, directiveRect, hostRect) {\n      const offset = this.directive.sided ? this.elementRef.nativeElement.getBoundingClientRect().width + DEFAULT_MARGIN : 0;\n      const left = Math.ceil(directiveRect.left - hostRect.left - offset);\n      const right = Math.floor(hostRect.right - directiveRect.right - offset);\n\n      switch (this.getFinalAlign(style, directiveRect)) {\n        case 'left':\n          if (right + DEFAULT_MARGIN > this.windowRef.innerWidth || inRange(left + DEFAULT_MARGIN, 0, this.windowRef.innerWidth)) {\n            style.left = px(left);\n            style.right = 'auto';\n          } else {\n            style.left = 'auto';\n            style.right = px(right);\n          }\n\n          break;\n\n        case 'right':\n          if (inRange(right + DEFAULT_MARGIN, 0, this.windowRef.innerWidth) || left + DEFAULT_MARGIN > this.windowRef.innerWidth) {\n            style.left = 'auto';\n            style.right = px(right);\n          } else {\n            style.left = px(left);\n            style.right = 'auto';\n          }\n\n          break;\n      }\n    }\n    /**\n     * Calculates vertical position and height\n     *\n     * @param style dropdownBox elementRef styles object\n     * @param directiveRect ClientRect of hosting directive\n     * @param hostRect ClientRect of  portal host\n     */\n\n\n    calculateVerticalPosition(style, directiveRect, hostRect) {\n      const windowHeight = this.windowRef.innerHeight; // Maximum height of the box\n\n      const boxHeightLimit = Math.min(this.directive.maxHeight, windowHeight - DEFAULT_MARGIN * 2);\n      const offset = this.directive.sided ? DEFAULT_MARGIN - directiveRect.height : DEFAULT_MARGIN * 2;\n      const topAvailableHeight = directiveRect.top - offset;\n      const bottomAvailableHeight = windowHeight - directiveRect.bottom - offset;\n      const finalDirection = this.getFinalDirection(directiveRect);\n      this.prevDirectionIsTop = finalDirection === 'top';\n\n      if (finalDirection === 'top') {\n        this.dropdownAnimation = this.animationBottom;\n        style.maxHeight = px(Math.min(boxHeightLimit, topAvailableHeight));\n        style.top = 'auto';\n        style.bottom = px(hostRect.bottom - directiveRect.top - DEFAULT_MARGIN + offset);\n      } else {\n        this.dropdownAnimation = this.animationTop;\n        style.maxHeight = px(Math.min(boxHeightLimit, bottomAvailableHeight));\n        style.top = px(directiveRect.bottom - hostRect.top - DEFAULT_MARGIN + offset);\n        style.bottom = 'auto';\n      }\n    }\n\n    getFinalDirection(directiveRect) {\n      const windowHeight = this.windowRef.innerHeight;\n      const offset = this.directive.sided ? DEFAULT_MARGIN - directiveRect.height : DEFAULT_MARGIN * 2; // Maximum space available on top and on the bottom in the viewport\n\n      const topAvailableHeight = directiveRect.top - offset;\n      const bottomAvailableHeight = windowHeight - directiveRect.bottom - offset;\n      let finalDirection = null; // Given direction is applied if we can fit the box in the limits that way\n\n      switch (this.directive.direction) {\n        case 'top':\n          if (topAvailableHeight >= this.directive.minHeight) {\n            finalDirection = 'top';\n          }\n\n          break;\n\n        case 'bottom':\n          if (bottomAvailableHeight >= this.directive.minHeight) {\n            finalDirection = 'bottom';\n          }\n\n          break;\n      } // Maximum height of the box\n\n\n      const boxHeightLimit = Math.min(this.directive.maxHeight, windowHeight - DEFAULT_MARGIN * 2); // Choose direction if given direction did not fit\n\n      if (finalDirection === null && this.contentElementRef) {\n        // Box height if it fits without scroll\n        const visualHeight = Math.min(this.contentElementRef.nativeElement.getBoundingClientRect().height + (this.elementRef.nativeElement.offsetHeight - this.elementRef.nativeElement.clientHeight), boxHeightLimit); // If there is enough space to fit below without scroll,\n        // choose 'bottom', unless it was previously on the top\n\n        if (this.prevDirectionIsTop && topAvailableHeight >= visualHeight) {\n          finalDirection = 'top';\n        } else if (bottomAvailableHeight >= visualHeight) {\n          finalDirection = 'bottom';\n        } else {\n          // Corner case — select direction with more space\n          finalDirection = bottomAvailableHeight >= topAvailableHeight ? 'bottom' : 'top';\n        }\n      }\n\n      return finalDirection;\n    }\n    /**\n     * Calculates width\n     *\n     * @param style dropdownBox elementRef styles object\n     * @param directiveRect ClientRect of hosting directive\n     */\n\n\n    calculateWidth(style, directiveRect) {\n      style.width = this.directive.limitMinWidth === 'fixed' && !this.directive.sided ? px(directiveRect.width) : '';\n\n      if (this.directive.limitMinWidth === 'min' && !this.directive.sided) {\n        style.minWidth = px(directiveRect.width);\n        style.maxWidth = px(DEFAULT_MAX_WIDTH);\n        return;\n      }\n\n      style.minWidth = '';\n      style.maxWidth = '';\n    }\n\n    moveFocusOutside(previous) {\n      const {\n        host\n      } = this.directive;\n      const {\n        ownerDocument\n      } = host;\n      const root = ownerDocument ? ownerDocument.body : host;\n      let focusable = getClosestFocusable(host, previous, root);\n\n      while (focusable !== null && host.contains(focusable)) {\n        focusable = getClosestFocusable(focusable, previous, root);\n      }\n\n      if (focusable === null) {\n        return;\n      }\n\n      setNativeFocused(focusable);\n    }\n\n  };\n\n  TuiDropdownBoxComponent.ɵfac = function TuiDropdownBoxComponent_Factory(t) {\n    return new (t || TuiDropdownBoxComponent)(ɵngcc0.ɵɵdirectiveInject(TuiDestroyService), ɵngcc0.ɵɵdirectiveInject(NgZone), ɵngcc0.ɵɵdirectiveInject(TUI_DROPDOWN_DIRECTIVE), ɵngcc0.ɵɵdirectiveInject(WINDOW), ɵngcc0.ɵɵdirectiveInject(ElementRef), ɵngcc0.ɵɵdirectiveInject(AbstractTuiPortalHostComponent), ɵngcc0.ɵɵdirectiveInject(TUI_ANIMATION_OPTIONS), ɵngcc0.ɵɵdirectiveInject(ANIMATION_FRAME));\n  };\n\n  TuiDropdownBoxComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: TuiDropdownBoxComponent,\n    selectors: [[\"tui-dropdown-box\"]],\n    viewQuery: function TuiDropdownBoxComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵviewQuery(_c0, 5, ElementRef);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.contentElementRef = _t.first);\n      }\n    },\n    hostVars: 1,\n    hostBindings: function TuiDropdownBoxComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        ɵngcc0.ɵɵsyntheticHostProperty(\"@tuiDropdownAnimation\", ctx.dropdownAnimation);\n      }\n    },\n    features: [ɵngcc0.ɵɵProvidersFeature([TuiDestroyService])],\n    decls: 7,\n    vars: 5,\n    consts: [[1, \"wrapper\", 3, \"tuiOverscroll\", \"tuiMode\", \"tuiActiveZoneParent\"], [\"activeZone\", \"tuiActiveZone\"], [1, \"scroll\"], [\"tabindex\", \"0\", 3, \"focus\"], [\"polymorpheus-outlet\", \"\", 1, \"content\", 3, \"content\", \"context\"], [\"content\", \"\"]],\n    template: function TuiDropdownBoxComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵelementStart(0, \"div\", 0, 1)(2, \"tui-scrollbar\", 2)(3, \"div\", 3);\n        ɵngcc0.ɵɵlistener(\"focus\", function TuiDropdownBoxComponent_Template_div_focus_3_listener() {\n          return ctx.onTopFocus();\n        });\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵelement(4, \"div\", 4, 5);\n        ɵngcc0.ɵɵelementStart(6, \"div\", 3);\n        ɵngcc0.ɵɵlistener(\"focus\", function TuiDropdownBoxComponent_Template_div_focus_6_listener() {\n          return ctx.onBottomFocus();\n        });\n        ɵngcc0.ɵɵelementEnd()()();\n      }\n\n      if (rf & 2) {\n        const _r0 = ɵngcc0.ɵɵreference(1);\n\n        ɵngcc0.ɵɵproperty(\"tuiOverscroll\", ctx.overscroll)(\"tuiMode\", null)(\"tuiActiveZoneParent\", ctx.directive.activeZone);\n        ɵngcc0.ɵɵadvance(4);\n        ɵngcc0.ɵɵproperty(\"content\", ctx.directive.content)(\"context\", ctx.getContext(ctx.directive.context, _r0));\n      }\n    },\n    directives: [ɵngcc1.TuiOverscrollDirective, ɵngcc2.TuiModeDirective, ɵngcc1.TuiActiveZoneDirective, ɵngcc3.TuiScrollbarComponent, ɵngcc4.PolymorpheusOutletComponent],\n    styles: [\"[_nghost-%COMP%]{z-index:0;box-shadow:0 .5rem 1rem rgba(0,0,0,.16);position:absolute;top:0;left:0;display:flex;background-color:#fff;background-color:var(--tui-elevation-01);border-radius:var(--tui-radius-m);overflow:hidden;border:1px solid var(--tui-base-03);box-sizing:border-box}.ng-animating[_nghost-%COMP%]{pointer-events:none}.content[_ngcontent-%COMP%]{display:flex;flex-direction:column;max-height:100%}.wrapper[_ngcontent-%COMP%]{flex-grow:1;max-width:100%;max-height:inherit;overflow:visible}.scroll[_ngcontent-%COMP%]{height:100%}\"],\n    data: {\n      animation: [tuiDropdownAnimation]\n    }\n  });\n\n  __decorate([HostBinding('@tuiDropdownAnimation')], TuiDropdownBoxComponent.prototype, \"dropdownAnimation\", void 0);\n\n  __decorate([ViewChild('content', {\n    read: ElementRef\n  })], TuiDropdownBoxComponent.prototype, \"contentElementRef\", void 0);\n\n  __decorate([tuiPure], TuiDropdownBoxComponent.prototype, \"getContext\", null);\n\n  __decorate([tuiPure], TuiDropdownBoxComponent.prototype, \"inModal\", null);\n\n  TuiDropdownBoxComponent = __decorate([__param(0, Inject(TuiDestroyService)), __param(1, Inject(NgZone)), __param(2, Inject(TUI_DROPDOWN_DIRECTIVE)), __param(3, Inject(WINDOW)), __param(4, Inject(ElementRef)), __param(5, Inject(AbstractTuiPortalHostComponent)), __param(6, Inject(TUI_ANIMATION_OPTIONS)), __param(7, Inject(ANIMATION_FRAME))], TuiDropdownBoxComponent);\n  return TuiDropdownBoxComponent;\n})();\nlet TuiDropdownBoxModule = /*#__PURE__*/(() => {\n  let TuiDropdownBoxModule = class TuiDropdownBoxModule {};\n\n  TuiDropdownBoxModule.ɵfac = function TuiDropdownBoxModule_Factory(t) {\n    return new (t || TuiDropdownBoxModule)();\n  };\n\n  TuiDropdownBoxModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: TuiDropdownBoxModule\n  });\n  TuiDropdownBoxModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    imports: [[TuiActiveZoneModule, PolymorpheusModule, TuiOverscrollModule, TuiScrollbarModule, TuiModeModule]]\n  });\n  return TuiDropdownBoxModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(TuiDropdownBoxModule, {\n    declarations: function () {\n      return [TuiDropdownBoxComponent];\n    },\n    imports: function () {\n      return [TuiActiveZoneModule, PolymorpheusModule, TuiOverscrollModule, TuiScrollbarModule, TuiModeModule];\n    },\n    exports: function () {\n      return [TuiDropdownBoxComponent];\n    }\n  });\n})();\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { TuiDropdownBoxComponent, TuiDropdownBoxModule }; //# sourceMappingURL=taiga-ui-core-components-dropdown-box.js.map","map":null,"metadata":{},"sourceType":"module"}