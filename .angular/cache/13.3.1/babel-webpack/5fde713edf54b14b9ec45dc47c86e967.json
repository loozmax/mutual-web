{"ast":null,"code":"import { __decorate, __param } from 'tslib';\nimport { Input, HostBinding, Directive, ChangeDetectorRef, Inject, ViewChild } from '@angular/core';\nimport { AbstractTuiControl, clamp, round, tuiDefaultProp, tuiPure, typedFromEvent, setNativeFocused, quantize, nonNegativeFiniteAssertion } from '@taiga-ui/cdk';\nimport { tuiCreateNumberMask, tuiCreateAutoCorrectedNumberPipe, tuiPluralizeToICU, maskedNumberStringToNumber } from '@taiga-ui/core';\nimport { tuiEnableAutoCorrectDecimalSymbol } from '@taiga-ui/core/utils';\nimport { TUI_FLOATING_PRECISION } from '@taiga-ui/kit/constants';\nimport { getPrecision } from '@taiga-ui/kit/utils';\nimport { NgControl } from '@angular/forms';\nimport { TUI_FROM_TO_TEXTS } from '@taiga-ui/kit/tokens';\nimport { Subject, race, Observable } from 'rxjs';\nimport { map, switchMap, takeUntil } from 'rxjs/operators';\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from '@angular/forms';\nimport * as ɵngcc2 from 'rxjs';\nconst _c0 = [\"dotLeft\"];\nconst _c1 = [\"dotRight\"];\n\nfunction quantumAssertion(quantum) {\n  return quantum > 0;\n}\n/**\n * @internal\n * @deprecated TODO delete me after `InputSlider` and `InputRange` stop using it\n */\n\n\nlet AbstractTuiInputSlider = /*#__PURE__*/(() => {\n  let AbstractTuiInputSlider = class AbstractTuiInputSlider extends AbstractTuiControl {\n    constructor() {\n      super(...arguments);\n      this.min = 0;\n      this.max = Infinity;\n      this.minLabel = '';\n      this.maxLabel = '';\n      this.segments = 0;\n      this.steps = 0;\n      this.quantum = 1;\n      this.keySteps = null;\n      this.size = 'l';\n      this.pluralizeMap = null;\n      /** @deprecated TODO remove in v3.0 */\n\n      this.segmentsPluralizeMap = null;\n      /** @deprecated TODO remove in v3.0 */\n\n      this.pluralizeMapFallback = {\n        one: '',\n        few: '',\n        many: '',\n        other: ''\n      };\n\n      this.mask = (quantum, min) => ({\n        mask: tuiCreateNumberMask({\n          allowNegative: min < 0,\n          allowDecimal: !Number.isInteger(quantum),\n          decimalSymbol: this.numberFormat.decimalSeparator,\n          thousandSymbol: this.numberFormat.thousandSeparator,\n          decimalLimit: getPrecision(quantum),\n          autoCorrectDecimalSymbol: tuiEnableAutoCorrectDecimalSymbol(this.numberFormat)\n        }),\n        pipe: tuiCreateAutoCorrectedNumberPipe(0, this.numberFormat.decimalSeparator, this.numberFormat.thousandSeparator, undefined, min < 0),\n        guide: false\n      });\n    } // TODO: remove setter in v3.0:\n\n\n    set pluralize(pluralize) {\n      this.pluralizeMap = Array.isArray(pluralize) ? tuiPluralizeToICU(pluralize) : pluralize;\n    }\n    /**\n     * @deprecated This input-property will be deleted in next major update.\n     * You can create ticks labels below this input by yourself. It is easy!\n     * Mixin `tui-slider-ticks-labels` will help with it. See examples in demo page `InputSlider`.\n     * ___\n     * TODO remove in v3.0.\n     * Dont forget to delete:\n     *** {@link segmentsPluralizeMap}\n     *** {@link getTickPrefix}\n     *** TuiFormatNumberPipeModule\n     *** TuiRepeatTimesModule\n     */\n\n\n    set segmentsPluralize(pluralize) {\n      this.segmentsPluralizeMap = Array.isArray(pluralize) ? tuiPluralizeToICU(pluralize) : pluralize;\n    }\n    /** @deprecated TODO remove in v3.0 */\n\n\n    getTickPrefix(segment, segments, texts) {\n      if (segments !== 1) {\n        return '';\n      }\n\n      return segment === 0 ? `${texts[0]}` : `${texts[1]}`;\n    }\n\n    get segmented() {\n      return this.segments > 0;\n    }\n\n    get hasPlaceholder() {\n      return this.size === 'l';\n    }\n\n    get inputMode() {\n      return Number.isInteger(this.quantum) ? 'numeric' : 'decimal';\n    }\n\n    get length() {\n      return this.max - this.min;\n    }\n\n    get computedSteps() {\n      return this.steps || this.length / this.quantum;\n    }\n\n    get step() {\n      return this.length / this.computedSteps;\n    }\n\n    get computedKeySteps() {\n      return this.computePureKeySteps(this.keySteps, this.min, this.max);\n    }\n\n    onHovered(hovered) {\n      this.updateHovered(hovered);\n    }\n\n    valueGuard(value) {\n      return this.quantum ? clamp(round(Math.round(value / this.quantum) * this.quantum, TUI_FLOATING_PRECISION), this.min, this.max) : clamp(value, this.min, this.max);\n    }\n\n    capInputValue(value, max = this.max) {\n      const capped = Math.min(maskedNumberStringToNumber(value, this.numberFormat.decimalSeparator, this.numberFormat.thousandSeparator), max);\n\n      if (this.min < 0 && capped < this.min) {\n        return this.min;\n      }\n\n      return isNaN(capped) || capped < this.min ? null : capped;\n    }\n\n    computePureKeySteps(keySteps, min, max) {\n      return [[0, min], ...(keySteps || []), [100, max]];\n    }\n\n  };\n\n  AbstractTuiInputSlider.ɵfac = /*@__PURE__*/function () {\n    let ɵAbstractTuiInputSlider_BaseFactory;\n    return function AbstractTuiInputSlider_Factory(t) {\n      return (ɵAbstractTuiInputSlider_BaseFactory || (ɵAbstractTuiInputSlider_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(AbstractTuiInputSlider)))(t || AbstractTuiInputSlider);\n    };\n  }();\n\n  AbstractTuiInputSlider.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: AbstractTuiInputSlider,\n    hostVars: 3,\n    hostBindings: function AbstractTuiInputSlider_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        ɵngcc0.ɵɵattribute(\"data-size\", ctx.size);\n        ɵngcc0.ɵɵclassProp(\"_segmented\", ctx.segmented);\n      }\n    },\n    inputs: {\n      min: \"min\",\n      max: \"max\",\n      minLabel: \"minLabel\",\n      maxLabel: \"maxLabel\",\n      segments: \"segments\",\n      steps: \"steps\",\n      quantum: \"quantum\",\n      keySteps: \"keySteps\",\n      size: \"size\",\n      pluralize: \"pluralize\",\n      segmentsPluralize: \"segmentsPluralize\"\n    },\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature]\n  });\n\n  __decorate([Input(), tuiDefaultProp()], AbstractTuiInputSlider.prototype, \"min\", void 0);\n\n  __decorate([Input(), tuiDefaultProp()], AbstractTuiInputSlider.prototype, \"max\", void 0);\n\n  __decorate([Input(), tuiDefaultProp()], AbstractTuiInputSlider.prototype, \"minLabel\", void 0);\n\n  __decorate([Input(), tuiDefaultProp()], AbstractTuiInputSlider.prototype, \"maxLabel\", void 0);\n\n  __decorate([Input(), tuiDefaultProp()], AbstractTuiInputSlider.prototype, \"pluralize\", null);\n\n  __decorate([Input(), tuiDefaultProp()], AbstractTuiInputSlider.prototype, \"segmentsPluralize\", null);\n\n  __decorate([Input(), tuiDefaultProp()], AbstractTuiInputSlider.prototype, \"segments\", void 0);\n\n  __decorate([Input(), tuiDefaultProp()], AbstractTuiInputSlider.prototype, \"steps\", void 0);\n\n  __decorate([Input(), tuiDefaultProp(quantumAssertion, 'Quantum must be positive')], AbstractTuiInputSlider.prototype, \"quantum\", void 0);\n\n  __decorate([Input(), tuiDefaultProp()], AbstractTuiInputSlider.prototype, \"keySteps\", void 0);\n\n  __decorate([Input(), HostBinding('attr.data-size')], AbstractTuiInputSlider.prototype, \"size\", void 0);\n\n  __decorate([tuiPure], AbstractTuiInputSlider.prototype, \"getTickPrefix\", null);\n\n  __decorate([HostBinding('class._segmented')], AbstractTuiInputSlider.prototype, \"segmented\", null);\n\n  __decorate([tuiPure], AbstractTuiInputSlider.prototype, \"computePureKeySteps\", null);\n\n  return AbstractTuiInputSlider;\n})();\nconst SLIDER_KEYBOARD_STEP = 0.05;\nconst DOT_WIDTH = {\n  s: 8,\n  m: 16\n};\n/**\n * @awful TODO: refactor\n * @internal\n * @dynamic\n */\n\nlet AbstractTuiSlider = /*#__PURE__*/(() => {\n  let AbstractTuiSlider = class AbstractTuiSlider extends AbstractTuiControl {\n    constructor(ngControl, changeDetectorRef, documentRef, fromToTexts$) {\n      super(ngControl, changeDetectorRef);\n      this.documentRef = documentRef;\n      this.fromToTexts$ = fromToTexts$; // @bad TODO: handle pointer events instead of mouse and touch events\n\n      this.pointerDown$ = new Subject();\n      this.min = 0;\n      this.max = Infinity;\n      this.segments = 0;\n      this.steps = 0;\n      this.quantum = 0;\n      this.size = 'm';\n      this.keySteps = null;\n      this.focusVisibleLeft = false;\n      this.focusVisibleRight = false;\n      this.pluralizeMap = null;\n    } // TODO: remove setter in v3.0:\n\n\n    set pluralize(pluralize) {\n      this.pluralizeMap = Array.isArray(pluralize) ? tuiPluralizeToICU(pluralize) : pluralize;\n    }\n\n    get segmented() {\n      return this.segments > 0;\n    }\n\n    get discrete() {\n      return this.steps > 0;\n    }\n\n    get length() {\n      return this.max - this.min;\n    }\n\n    get computedStep() {\n      if (this.steps) {\n        return 1 / this.steps;\n      }\n\n      return this.quantum ? this.quantum / this.length : SLIDER_KEYBOARD_STEP;\n    }\n\n    get isLeftFocusable() {\n      return !this.disabled && this.focusable && this.right !== 100;\n    }\n\n    get isRightFocusable() {\n      return !this.disabled && this.focusable && this.left !== 100;\n    }\n\n    ngOnInit() {\n      super.ngOnInit();\n      const mouseMoves$ = typedFromEvent(this.documentRef, 'mousemove');\n      const mouseUps$ = typedFromEvent(this.documentRef, 'mouseup');\n      const touchMoves$ = typedFromEvent(this.documentRef, 'touchmove');\n      const touchEnds$ = typedFromEvent(this.documentRef, 'touchend');\n      let isPointerDownRight;\n      this.pointerDown$.pipe(map(event => {\n        const rect = event.currentTarget.getBoundingClientRect();\n        const clientX = event instanceof MouseEvent ? event.clientX : event.touches[0].clientX;\n        const fraction = clamp(this.getFractionFromEvents(rect, clientX), 0, 1);\n        const deltaLeft = fraction * 100 - this.left;\n        const deltaRight = fraction * 100 - 100 + this.right;\n        isPointerDownRight = Math.abs(deltaLeft) > Math.abs(deltaRight) || deltaRight > 0 || this.left === 0 && this.right === 100;\n        const calibratedFraction = clamp(this.getCalibratedFractionFromEvents(rect, clientX, isPointerDownRight), 0, 1);\n        const value = this.getValueFromFraction(this.fractionGuard(calibratedFraction));\n        this.processValue(value, isPointerDownRight);\n        this.processFocus(isPointerDownRight);\n        return rect;\n      }), switchMap(rect => race([touchMoves$, mouseMoves$]).pipe(map(event => this.getCalibratedFractionFromEvents(rect, event instanceof MouseEvent ? event.clientX : event.touches[0].clientX, isPointerDownRight)), takeUntil(race([mouseUps$, touchEnds$])))), map(fraction => this.fractionGuard(fraction))).subscribe(fraction => {\n        this.processValue(this.getValueFromFraction(fraction), isPointerDownRight);\n      });\n    }\n\n    ngOnDestroy() {\n      super.ngOnDestroy();\n      this.pointerDown$.complete();\n    }\n\n    onMouseDown(event) {\n      if (this.disabled) {\n        return;\n      }\n\n      event.preventDefault();\n      this.pointerDown$.next(event);\n    }\n\n    onTouchStart(event) {\n      if (this.disabled) {\n        return;\n      }\n\n      event.preventDefault();\n      this.pointerDown$.next(event);\n    }\n\n    decrement(right) {\n      this.processStep(false, right);\n    }\n\n    increment(right) {\n      this.processStep(true, right);\n    }\n\n    getSegmentLabel(segment) {\n      return round(this.getValueFromFraction(segment / this.segments), 2);\n    }\n\n    getSegmentPrefix(segment, texts) {\n      if (this.segments !== 1) {\n        return '';\n      }\n\n      if (segment === 0) {\n        return `${texts[0]} `;\n      }\n\n      return `${texts[1]} `;\n    }\n\n    onActiveZone(active) {\n      this.updateFocused(active);\n    }\n\n    onLeftFocusVisible(focusVisible) {\n      this.focusVisibleLeft = focusVisible;\n    }\n\n    onRightFocusVisible(focusVisible) {\n      this.focusVisibleRight = focusVisible;\n    }\n\n    getFractionFromValue(value) {\n      const fraction = (value - this.min) / this.length;\n      return this.keySteps !== null ? this.fractionValueKeyStepConverter(value, false) : clamp(Number.isFinite(fraction) ? fraction : 1, 0, 1);\n    }\n\n    getValueFromFraction(fraction) {\n      return this.keySteps !== null ? this.fractionValueKeyStepConverter(fraction, true) : round(this.fractionGuard(fraction) * this.length + this.min, TUI_FLOATING_PRECISION);\n    }\n\n    getCalibratedFractionFromEvents(rect, clientX, _) {\n      return this.getFractionFromEvents(rect, clientX);\n    }\n\n    valueGuard(value) {\n      return this.quantum ? clamp(round(Math.round(value / this.quantum) * this.quantum, TUI_FLOATING_PRECISION), this.min, this.max) : clamp(value, this.min, this.max);\n    }\n\n    processFocus(right) {\n      if (!this.focusable || !this.dotRight || !this.dotLeft) {\n        return;\n      }\n\n      if (right) {\n        setNativeFocused(this.dotRight.nativeElement);\n      } else {\n        setNativeFocused(this.dotLeft.nativeElement);\n      }\n    }\n    /**\n     * Function for converting the fullness of the slider to a value and vice versa\n     * taking into account the steps of linear dependence.\n     *\n     * @param value passed value\n     * @param isFraction translation is carried out from fullness to value\n     */\n\n\n    fractionValueKeyStepConverter(value, isFraction) {\n      const steps = [[0, this.min]].concat(this.keySteps, [[100, this.max]]);\n      let prevFraction = 0;\n      let nextFraction = 100;\n      let prevValue = this.min;\n      let nextValue = this.max;\n\n      for (let i = 1; i < steps.length; i++) {\n        if (isFraction && steps[i][0] / 100 > value || !isFraction && steps[i][1] > value) {\n          prevFraction = steps[i - 1][0] || 0;\n          nextFraction = steps[i][0];\n          prevValue = steps[i - 1][1];\n          nextValue = steps[i][1];\n          break;\n        }\n      }\n\n      const deltaFraction = nextFraction - prevFraction;\n      const deltaValue = nextValue - prevValue;\n      return isFraction ? round((value * 100 - prevFraction) / deltaFraction * deltaValue + prevValue, TUI_FLOATING_PRECISION) : clamp((value - prevValue) / deltaValue * deltaFraction + prevFraction, 0, 100) / 100;\n    }\n\n    fractionGuard(fraction) {\n      return this.discrete ? clamp(quantize(fraction, 1 / this.steps), 0, 1) : clamp(fraction, 0, 1);\n    }\n\n    getFractionFromEvents(rect, clientX) {\n      const value = clientX - rect.left - DOT_WIDTH[this.size] / 2;\n      const total = rect.width - DOT_WIDTH[this.size];\n      return round(value / total, TUI_FLOATING_PRECISION);\n    }\n\n  };\n\n  AbstractTuiSlider.ɵfac = function AbstractTuiSlider_Factory(t) {\n    return new (t || AbstractTuiSlider)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(Document), ɵngcc0.ɵɵdirectiveInject(TUI_FROM_TO_TEXTS));\n  };\n\n  AbstractTuiSlider.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: AbstractTuiSlider,\n    viewQuery: function AbstractTuiSlider_Query(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵviewQuery(_c0, 5);\n        ɵngcc0.ɵɵviewQuery(_c1, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.dotLeft = _t.first);\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.dotRight = _t.first);\n      }\n    },\n    hostVars: 3,\n    hostBindings: function AbstractTuiSlider_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        ɵngcc0.ɵɵattribute(\"data-size\", ctx.size);\n        ɵngcc0.ɵɵclassProp(\"_segmented\", ctx.segmented);\n      }\n    },\n    inputs: {\n      min: \"min\",\n      max: \"max\",\n      segments: \"segments\",\n      steps: \"steps\",\n      quantum: \"quantum\",\n      size: \"size\",\n      keySteps: \"keySteps\",\n      pluralize: \"pluralize\"\n    },\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature]\n  });\n\n  __decorate([ViewChild('dotLeft')], AbstractTuiSlider.prototype, \"dotLeft\", void 0);\n\n  __decorate([ViewChild('dotRight')], AbstractTuiSlider.prototype, \"dotRight\", void 0);\n\n  __decorate([Input(), tuiDefaultProp()], AbstractTuiSlider.prototype, \"min\", void 0);\n\n  __decorate([Input(), tuiDefaultProp()], AbstractTuiSlider.prototype, \"max\", void 0);\n\n  __decorate([Input(), tuiDefaultProp()], AbstractTuiSlider.prototype, \"segments\", void 0);\n\n  __decorate([Input(), tuiDefaultProp()], AbstractTuiSlider.prototype, \"steps\", void 0);\n\n  __decorate([Input(), tuiDefaultProp(nonNegativeFiniteAssertion, 'Quantum must be a non-negative number')], AbstractTuiSlider.prototype, \"quantum\", void 0);\n\n  __decorate([Input(), tuiDefaultProp()], AbstractTuiSlider.prototype, \"pluralize\", null);\n\n  __decorate([Input(), HostBinding('attr.data-size'), tuiDefaultProp()], AbstractTuiSlider.prototype, \"size\", void 0);\n\n  __decorate([Input(), tuiDefaultProp()], AbstractTuiSlider.prototype, \"keySteps\", void 0);\n\n  __decorate([HostBinding('class._segmented')], AbstractTuiSlider.prototype, \"segmented\", null);\n\n  AbstractTuiSlider = __decorate([__param(3, Inject(TUI_FROM_TO_TEXTS))], AbstractTuiSlider);\n  return AbstractTuiSlider;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { AbstractTuiInputSlider, AbstractTuiSlider, DOT_WIDTH, SLIDER_KEYBOARD_STEP, quantumAssertion }; //# sourceMappingURL=taiga-ui-kit-abstract.js.map","map":null,"metadata":{},"sourceType":"module"}