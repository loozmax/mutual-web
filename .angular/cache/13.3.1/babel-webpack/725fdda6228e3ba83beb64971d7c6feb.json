{"ast":null,"code":"import { tuiAssert } from '@taiga-ui/cdk/classes';\n/**\n * Clamps a value between two inclusive limits\n *\n * @param value\n * @param min lower limit\n * @param max upper limit\n */\n\nfunction clamp(value, min, max) {\n  tuiAssert.assert(!isNaN(value));\n  tuiAssert.assert(!isNaN(min));\n  tuiAssert.assert(!isNaN(max));\n  tuiAssert.assert(max >= min);\n  return Math.min(max, Math.max(min, value));\n}\n/**\n * Checks if the value is in range\n *\n * @param value\n * @param fromInclude lower inclusive limit\n * @param toExclude upper exclusive limit\n */\n\n\nfunction inRange(value, fromInclude, toExclude) {\n  tuiAssert.assert(!isNaN(value));\n  tuiAssert.assert(!isNaN(fromInclude));\n  tuiAssert.assert(!isNaN(toExclude));\n  tuiAssert.assert(fromInclude < toExclude);\n  return value >= fromInclude && value < toExclude;\n}\n/**\n * Normalizes any number to an integer within inclusive range\n *\n * @param value\n * @param min lower inclusive integer\n * @param max upper inclusive integer\n * @return an integer between min and max inclusive\n */\n\n\nfunction normalizeToIntNumber(value, min, max) {\n  tuiAssert.assert(Number.isInteger(min));\n  tuiAssert.assert(Number.isInteger(max));\n  tuiAssert.assert(min <= max);\n\n  if (isNaN(value) || value <= min) {\n    return min;\n  }\n\n  if (value >= max) {\n    return max;\n  }\n\n  return Math.round(value);\n}\n/**\n * Rounds a number to the closest value in a fixed discrete series\n *\n * @param value\n * @param quantum series step\n */\n\n\nfunction quantize(value, quantum) {\n  tuiAssert.assert(Number.isFinite(value));\n  tuiAssert.assert(Number.isFinite(quantum));\n  tuiAssert.assert(quantum > 0);\n  const remainder = value % quantum;\n  return remainder < quantum / 2 ? value - remainder : value + quantum - remainder;\n}\n\nconst MAX_PRECISION = 292;\n\nfunction round(value, precision = 0) {\n  return calculate(value, precision, Math.round);\n}\n\nfunction ceil(value, precision = 0) {\n  return calculate(value, precision, Math.ceil);\n}\n\nfunction floor(value, precision = 0) {\n  return calculate(value, precision, Math.floor);\n}\n/**\n * Rounding number to the set precision\n *\n * @param value\n * @param precision number of digits in a float part\n * @param func rounding function (round, floor, ceil)\n */\n\n\nfunction calculate(value, precision, func) {\n  if (value === Infinity) {\n    return value;\n  }\n\n  tuiAssert.assert(!isNaN(value), 'Value must be number');\n  tuiAssert.assert(Number.isInteger(precision), 'Precision must be integer');\n  precision = Math.min(precision, MAX_PRECISION);\n  const pair = `${value}e`.split('e');\n  const tempValue = func(Number(`${pair[0]}e${Number(pair[1]) + precision}`));\n  const processedPair = `${tempValue}e`.split('e');\n  return Number(`${processedPair[0]}e${Number(processedPair[1]) - precision}`);\n}\n/**\n * Calculates sum of any number of passed arguments\n */\n\n\nfunction sum(...args) {\n  return args.reduce((a, b) => a + b, 0);\n}\n\nfunction toInt(bool) {\n  return bool ? 1 : 0;\n}\n/**\n * Converts angle in degrees to radians\n */\n\n\nfunction toRadians(deg) {\n  return deg * Math.PI / 180;\n}\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { ceil, clamp, floor, inRange, normalizeToIntNumber, quantize, round, sum, toInt, toRadians }; //# sourceMappingURL=taiga-ui-cdk-utils-math.js.map","map":null,"metadata":{},"sourceType":"module"}