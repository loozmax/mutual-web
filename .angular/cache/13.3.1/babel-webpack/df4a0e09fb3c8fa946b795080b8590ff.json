{"ast":null,"code":"import { CHAR_NO_BREAK_SPACE, tuiAssert, isSafari, isNativeFocused, getDocumentOrShadowRoot, CHAR_EN_DASH } from '@taiga-ui/cdk';\nimport { MASK_CARET_TRAP, TUI_DIGIT_REGEXP, TUI_NON_DIGITS_REGEXP, TUI_LEADING_ZEROES_REGEXP, TUI_DECIMAL_SYMBOLS } from '@taiga-ui/core/constants';\nimport { otherDecimalSymbol } from '@taiga-ui/core/utils/format';\n/**\n * Used to finish a number with zeros to a given precision\n */\n\nfunction tuiCreateAutoCorrectedNumberPipe(decimalLimit = 0, decimalSymbol = ',', thousandSymbol = CHAR_NO_BREAK_SPACE, nativeInput, allowNegative, isIOS = false) {\n  tuiAssert.assert(Number.isInteger(decimalLimit));\n  tuiAssert.assert(decimalLimit >= 0); // Guess for which browser I need this :)\n\n  let previousCaret = -1;\n  const unlucky = !!nativeInput && isSafari(nativeInput) || isIOS;\n\n  if (nativeInput && unlucky) {\n    nativeInput.addEventListener('beforeinput', () => {\n      previousCaret = nativeInput.selectionStart || 0;\n    });\n  }\n\n  return (conformedValue, config) => {\n    // Removing everything by selecting and pressing '-'\n    if (!conformedValue && config.rawValue === '-' && allowNegative) {\n      return '-';\n    } // remove these hacks after text mask library has changed\n\n\n    if (nativeInput && unlucky && isNativeFocused(nativeInput)) {\n      const caret = calculateSafariCaret(config.previousConformedValue, conformedValue, previousCaret);\n      setTimeout(() => {\n        nativeInput.setSelectionRange(caret, caret);\n      });\n    }\n\n    if (nativeInput && nativeInput.ownerDocument !== getDocumentOrShadowRoot(nativeInput) && isNativeFocused(nativeInput) && config.currentCaretPosition) {\n      const realCaretPosition = config.currentCaretPosition + calculateCaretGap(config.previousConformedValue, conformedValue, thousandSymbol);\n      setTimeout(() => {\n        nativeInput.setSelectionRange(realCaretPosition, realCaretPosition);\n      });\n    }\n\n    if (conformedValue === '' || !decimalLimit) {\n      return {\n        value: conformedValue\n      };\n    }\n\n    const withDecimalSymbol = addDecimalSymbolIfNeeded(conformedValue, decimalSymbol);\n    const decimalPart = withDecimalSymbol.split(decimalSymbol)[1];\n    const zeroPaddingSize = decimalLimit - decimalPart.length;\n    return {\n      value: withDecimalSymbol + '0'.repeat(zeroPaddingSize)\n    };\n  };\n}\n\nfunction addDecimalSymbolIfNeeded(value, decimalSymbol = ',') {\n  return !value.includes(decimalSymbol) ? value + decimalSymbol : value;\n}\n\nfunction calculateSafariCaret(previousValue = '', current, previousCaret, decimalSymbol = ',') {\n  const tailRegex = new RegExp(`${decimalSymbol}.+`);\n  const previousWithoutTail = previousValue.replace(tailRegex, '');\n  const currentWithoutTail = current.replace(tailRegex, '');\n  const pasteOrCutOperation = Math.abs(previousWithoutTail.length - currentWithoutTail.length) > 2;\n\n  if (pasteOrCutOperation) {\n    return current.length;\n  }\n\n  if (previousValue.length === current.length) {\n    if (previousValue.indexOf(decimalSymbol) <= previousCaret) {\n      return calculateChangedTailIndex(previousValue, current);\n    }\n\n    return previousWithoutTail === currentWithoutTail ? previousCaret - 1 : previousCaret + 1;\n  }\n\n  if (previousValue.length === 0) {\n    return 1;\n  }\n\n  const changeLength = current.length - previousValue.length;\n  return previousCaret + changeLength;\n}\n\nfunction calculateChangedTailIndex(previous, current) {\n  for (let i = 0; i < current.length; i++) {\n    if (previous[i] !== current[i]) {\n      return current[i] === '0' ? i : i + 1;\n    }\n  }\n\n  return current.length;\n}\n\nfunction calculateCaretGap(previousValue = '', current, thousandSymbol) {\n  const pasteOrCutOperation = Math.abs(previousValue.length - current.length) > 2;\n\n  if (pasteOrCutOperation) {\n    return 0;\n  }\n\n  const wereSpaces = previousValue.split(thousandSymbol).length;\n  const nowSpaces = current.split(thousandSymbol).length;\n  return nowSpaces - wereSpaces;\n}\n\nconst ASSERTION = 'Correction function must return single char or null';\n\nfunction tuiCreateCorrectionMask(allowed, correctionHandler) {\n  return rawValue => {\n    const mask = rawValue.split('').reduce((result, char, index) => {\n      const corrected = correctionHandler(char, index);\n      tuiAssert.assert(corrected === null || corrected.length === 1, ASSERTION);\n\n      if (!allowed.test(char) && !corrected) {\n        return result;\n      }\n\n      if (allowed.test(char)) {\n        return [...result, allowed];\n      }\n\n      if (corrected) {\n        return [...result, corrected, MASK_CARET_TRAP];\n      }\n\n      return result;\n    }, []);\n    const lastIndex = mask.lastIndexOf(MASK_CARET_TRAP);\n    const filtered = mask.filter((item, index) => item !== MASK_CARET_TRAP || index === lastIndex);\n    return filtered.some(item => item !== allowed) ? [...filtered, allowed] : filtered;\n  };\n}\n\nconst NON_ZERO_DIGIT = /[1-9]/;\n/**\n * Adaptation for {@link https://github.com/text-mask/text-mask/tree/master/addons#createnumbermask `createNumberMask`}\n */\n\nfunction tuiCreateNumberMask({\n  allowDecimal = false,\n  decimalSymbol = ',',\n  thousandSymbol = CHAR_NO_BREAK_SPACE,\n  autoCorrectDecimalSymbol = true,\n  decimalLimit = 2,\n  requireDecimal = false,\n  allowNegative = false,\n  integerLimit = 0\n} = {}) {\n  tuiAssert.assert(Number.isInteger(decimalLimit));\n  tuiAssert.assert(decimalLimit >= 0);\n  tuiAssert.assert(Number.isInteger(integerLimit));\n  tuiAssert.assert(integerLimit >= 0);\n  return (rawValue, {\n    previousConformedValue\n  }) => {\n    if (previousConformedValue && requireDecimal) {\n      const conformedWithoutSeparator = rawValue.split(thousandSymbol).join('');\n      const previousConformedValueWithoutDecimalSymbolAndSeparator = previousConformedValue.split(thousandSymbol).join('').split(decimalSymbol).join(''); // Forbid removal of decimal separator if decimal part is required\n\n      if (conformedWithoutSeparator === previousConformedValueWithoutDecimalSymbolAndSeparator) {\n        rawValue = previousConformedValue;\n      }\n    }\n\n    const isNegative = (rawValue[0] === '-' || rawValue[0] === CHAR_EN_DASH) && allowNegative;\n\n    if (isDecimalSymbol(rawValue, decimalSymbol, autoCorrectDecimalSymbol) && allowDecimal) {\n      return ['0', decimalSymbol, TUI_DIGIT_REGEXP];\n    }\n\n    if (isNegative) {\n      rawValue = rawValue.substr(1);\n    }\n\n    const decimalIndex = getDecimalSymbolIndex(rawValue, decimalSymbol, autoCorrectDecimalSymbol);\n    const hasDecimal = decimalIndex !== -1;\n    const integer = hasDecimal ? rawValue.slice(0, decimalIndex) : rawValue;\n    const thousandSeparators = integer.match(new RegExp(thousandSymbol, 'g')) || [];\n    const integerCapped = integerLimit ? integer.slice(0, integerLimit + thousandSeparators.length) : integer;\n    const integerCappedClean = integerCapped.replace(TUI_NON_DIGITS_REGEXP, '');\n    const [leadingZerosMatch] = integerCappedClean.match(TUI_LEADING_ZEROES_REGEXP) || [''];\n    const leadingZerosAmount = leadingZerosMatch.length;\n    const integerCappedZerosClean = integerCappedClean.replace(/^0+(?!\\.|$)/, '').trim();\n    const withSeparator = addThousandsSeparator(integerCappedZerosClean, thousandSymbol);\n    const mask = convertToMask(withSeparator);\n\n    if (hasDecimal && allowDecimal || requireDecimal) {\n      const fraction = hasDecimal ? convertToMask(rawValue.slice(decimalIndex + 1).replace(TUI_NON_DIGITS_REGEXP, '')) : [];\n      const fractionCapped = decimalLimit ? fraction.slice(0, decimalLimit) : fraction;\n\n      if (rawValue[decimalIndex] !== otherDecimalSymbol(decimalSymbol)) {\n        mask.push(MASK_CARET_TRAP);\n      }\n\n      mask.push(decimalSymbol, MASK_CARET_TRAP, ...fractionCapped);\n\n      for (let i = 0; i < decimalLimit - fractionCapped.length; i++) {\n        mask.push(TUI_DIGIT_REGEXP);\n      }\n    }\n\n    const isOnlyZeroDigit = mask.length === 1 && integerCappedZerosClean === '0';\n\n    if (isNegative) {\n      if (mask.length === 0) {\n        mask.push(TUI_DIGIT_REGEXP);\n      }\n\n      mask.unshift('-');\n    }\n\n    return preventLeadingZeroes(mask, isOnlyZeroDigit, leadingZerosAmount);\n  };\n}\n\nfunction preventLeadingZeroes(mask, isOnlyZeroDigit = false, leadingZerosAmount = 0) {\n  if (isOnlyZeroDigit || leadingZerosAmount === 0) {\n    return mask;\n  }\n\n  const firstDigitIndex = mask.indexOf(TUI_DIGIT_REGEXP);\n\n  if (firstDigitIndex === -1) {\n    return mask;\n  }\n\n  const secondMaskDigit = mask[firstDigitIndex + 1];\n  const isCaretTrap = secondMaskDigit === MASK_CARET_TRAP;\n\n  if (isCaretTrap && leadingZerosAmount === 1) {\n    return mask;\n  } else if (isCaretTrap) {\n    mask.unshift(NON_ZERO_DIGIT);\n    return mask;\n  }\n\n  mask[firstDigitIndex] = NON_ZERO_DIGIT;\n  return mask;\n}\n\nfunction getDecimalSymbolIndex(str, decimalSymbol, autoCorrectDecimalSymbol) {\n  if (!autoCorrectDecimalSymbol) {\n    return str.lastIndexOf(decimalSymbol);\n  }\n\n  return Math.max(str.lastIndexOf(decimalSymbol), str.lastIndexOf(otherDecimalSymbol(decimalSymbol)));\n}\n\nfunction isDecimalSymbol(str, decimalSymbol, autoCorrectDecimalSymbol) {\n  if (autoCorrectDecimalSymbol) {\n    return /^[,.]$/.test(str);\n  }\n\n  return str === decimalSymbol;\n}\n\nfunction convertToMask(strNumber) {\n  return strNumber.split('').map(char => TUI_DIGIT_REGEXP.test(char) ? TUI_DIGIT_REGEXP : char);\n}\n\nfunction addThousandsSeparator(strNumber, thousandSymbol) {\n  return strNumber.length > 3 ? strNumber.replace(/\\B(?=(\\d{3})+(?!\\d))/g, thousandSymbol) : strNumber;\n}\n\nfunction tuiEnableAutoCorrectDecimalSymbol({\n  thousandSeparator\n}) {\n  return !TUI_DECIMAL_SYMBOLS.includes(thousandSeparator);\n}\n\nfunction maskedMoneyValueIsEmpty(value) {\n  switch (value) {\n    case '':\n    case '-':\n    case ',':\n    case '-,':\n      return true;\n\n    default:\n      return false;\n  }\n}\n\nfunction maskedNumberStringToNumber(value, decimalsSymbol, thousandSymbol) {\n  return parseFloat(value.split(thousandSymbol).join('').split(decimalsSymbol).join('.'));\n}\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { maskedMoneyValueIsEmpty, maskedNumberStringToNumber, tuiCreateAutoCorrectedNumberPipe, tuiCreateCorrectionMask, tuiCreateNumberMask, tuiEnableAutoCorrectDecimalSymbol }; //# sourceMappingURL=taiga-ui-core-utils-mask.js.map","map":null,"metadata":{},"sourceType":"module"}