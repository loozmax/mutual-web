{"ast":null,"code":"import { TuiOwnerDocumentException, TuiValuePresentException, TuiValueChangesException } from '@taiga-ui/cdk/exceptions';\nimport { isPresent, getOriginalArrayFromQueryList } from '@taiga-ui/cdk/utils/miscellaneous';\nimport { fromEvent, merge, concat, pipe, timer, Observable } from 'rxjs';\nimport { take, map, endWith, takeWhile, repeat, switchMapTo, mapTo, startWith, distinctUntilChanged, shareReplay, filter, ignoreElements, withLatestFrom, tap } from 'rxjs/operators';\nimport { isNativeFocused } from '@taiga-ui/cdk/utils/focus';\n\nfunction typedFromEvent(target, event, options = {}) {\n  return fromEvent(target, event, options);\n}\n/**\n * Letting go of the mouse after it was pressed\n * @param target\n */\n\n\nfunction mouseDragFinishFrom(target) {\n  return merge(typedFromEvent(target, 'mouseup'), typedFromEvent(target, 'dragend'));\n}\n\nvar TuiDragStage = /*#__PURE__*/(() => {\n  (function (TuiDragStage) {\n    TuiDragStage[TuiDragStage[\"Start\"] = 0] = \"Start\";\n    TuiDragStage[TuiDragStage[\"Continues\"] = 1] = \"Continues\";\n    TuiDragStage[TuiDragStage[\"End\"] = 2] = \"End\";\n  })(TuiDragStage || (TuiDragStage = {}));\n\n  return TuiDragStage;\n})();\n\nclass TuiDragState {\n  constructor(stage, event) {\n    this.stage = stage;\n    this.event = event;\n  }\n\n}\n\nfunction dragAndDropFrom(element) {\n  const {\n    ownerDocument\n  } = element;\n\n  if (!ownerDocument) {\n    throw new TuiOwnerDocumentException();\n  }\n\n  return concat(typedFromEvent(element, 'mousedown').pipe(take(1), map(event => new TuiDragState(0\n  /* Start */\n  , event))), merge(typedFromEvent(ownerDocument, 'mousemove').pipe(map(event => new TuiDragState(1\n  /* Continues */\n  , event))), mouseDragFinishFrom(ownerDocument).pipe(take(1), map(event => new TuiDragState(2\n  /* End */\n  , event)), endWith(null))).pipe(takeWhile(isPresent))).pipe(repeat());\n}\n/**\n * Operator to set lifespan after which current value is considered obsolete\n */\n\n\nfunction tuiIsAlive(lifespan = 0) {\n  return pipe(switchMapTo(timer(lifespan).pipe(mapTo(false), startWith(true))), distinctUntilChanged());\n}\n\nlet documentMouseUpIsAlive$;\nlet documentMouseDownIsAlive$;\n\nfunction focusVisibleObservable(element) {\n  const elementBlur$ = typedFromEvent(element, 'blur');\n  const {\n    ownerDocument\n  } = element;\n\n  if (!ownerDocument) {\n    throw new TuiOwnerDocumentException();\n  }\n\n  if (!documentMouseDownIsAlive$ || !documentMouseUpIsAlive$) {\n    documentMouseUpIsAlive$ = typedFromEvent(ownerDocument, 'mouseup', {\n      capture: true\n    }).pipe(tuiIsAlive(), startWith(false), shareReplay(1));\n    documentMouseDownIsAlive$ = typedFromEvent(ownerDocument, 'mousedown', {\n      capture: true\n    }).pipe(tuiIsAlive(), startWith(false), shareReplay(1));\n  }\n\n  return merge( // focus events excluding ones that came right after mouse action\n  concat(typedFromEvent(element, 'focus').pipe(take(1)), // filtering out blur events when element remains focused so that we ignore browser tab focus loss\n  elementBlur$.pipe(filter(() => !isNativeFocused(element)), take(1), ignoreElements())).pipe(repeat(), withLatestFrom(documentMouseDownIsAlive$, documentMouseUpIsAlive$, (_event, elementActual, documentActual) => elementActual || documentActual), filter(isUserFocus => !isUserFocus))).pipe(switchMapTo(elementBlur$.pipe(mapTo(false), take(1), startWith(true))), distinctUntilChanged());\n}\n/**\n * Converts changes observable of a QueryList to an Observable of arrays\n */\n\n\nfunction itemsQueryListObservable(queryList) {\n  return queryList.changes.pipe(map(() => getOriginalArrayFromQueryList(queryList)), startWith(getOriginalArrayFromQueryList(queryList)));\n}\n\nfunction mustBePresent() {\n  return map(value => {\n    if (!isPresent(value)) {\n      throw new TuiValuePresentException();\n    }\n\n    return value;\n  });\n}\n\nfunction pressedObservable(element, {\n  onlyTrusted\n} = {\n  onlyTrusted: true\n}) {\n  const {\n    ownerDocument\n  } = element;\n\n  if (!ownerDocument) {\n    throw new TuiOwnerDocumentException();\n  }\n\n  return typedFromEvent(element, 'mousedown').pipe(filter(({\n    isTrusted\n  }) => isTrusted || !onlyTrusted), switchMapTo(mouseDragFinishFrom(ownerDocument).pipe(mapTo(false), take(1), startWith(true))));\n}\n\nfunction preventDefault() {\n  return tap(e => {\n    e.preventDefault();\n  });\n}\n/**\n * Turns AbstractControl/Abstract-control-directive valueChanges into ReplaySubject(1)\n * TODO: rename function in 3.0. The name should be shorter.\n */\n\n\nfunction tuiReplayedValueChangesFrom(control) {\n  return new Observable(subscriber => {\n    if (!control.valueChanges) {\n      throw new TuiValueChangesException();\n    }\n\n    control.valueChanges.pipe(startWith(control.value)).subscribe(subscriber);\n  });\n}\n\nfunction stopPropagation() {\n  return tap(e => {\n    e.stopPropagation();\n  });\n}\n\nfunction watch(changeDetectorRef) {\n  return tap(() => {\n    changeDetectorRef.markForCheck();\n  });\n}\n\nfunction tuiZonefull(ngZone) {\n  return source => new Observable(subscriber => source.subscribe({\n    next: value => ngZone.run(() => subscriber.next(value)),\n    error: error => ngZone.run(() => subscriber.error(error)),\n    complete: () => ngZone.run(() => subscriber.complete())\n  }));\n}\n\nfunction tuiZonefree(ngZone) {\n  return source => new Observable(subscriber => ngZone.runOutsideAngular(() => source.subscribe(subscriber)));\n}\n\nfunction tuiZoneOptimized(ngZone) {\n  return pipe(tuiZonefree(ngZone), tuiZonefull(ngZone));\n}\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { TuiDragStage, TuiDragState, dragAndDropFrom, focusVisibleObservable, itemsQueryListObservable, mouseDragFinishFrom, mustBePresent, pressedObservable, preventDefault, stopPropagation, tuiIsAlive, tuiReplayedValueChangesFrom, tuiZoneOptimized, tuiZonefree, tuiZonefull, typedFromEvent, watch }; //# sourceMappingURL=taiga-ui-cdk-observables.js.map","map":null,"metadata":{},"sourceType":"module"}