{"ast":null,"code":"import { __decorate, __param } from 'tslib';\nimport { EventEmitter, Input, Output, HostBinding, Directive, ChangeDetectorRef, Inject, Injectable, TemplateRef, Injector, ElementRef, ViewChild, ViewContainerRef } from '@angular/core';\nimport { NgModel, NgControl } from '@angular/forms';\nimport { tuiAssert } from '@taiga-ui/cdk/classes';\nimport { EMPTY_FUNCTION } from '@taiga-ui/cdk/constants';\nimport { tuiDefaultProp } from '@taiga-ui/cdk/decorators';\nimport { Subject, merge, Observable, BehaviorSubject, EMPTY } from 'rxjs';\nimport { takeUntil, switchMap, ignoreElements, endWith } from 'rxjs/operators';\nimport { PolymorpheusTemplate } from '@tinkoff/ng-polymorpheus';\nimport { TuiIdService } from '@taiga-ui/cdk/services';\nimport { TuiNoHostException } from '@taiga-ui/cdk/exceptions';\nimport { DOCUMENT } from '@angular/common';\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from '@angular/forms';\nimport * as ɵngcc2 from '@taiga-ui/cdk/services';\nconst _c0 = [\"viewContainer\"];\nvar AbstractTuiInteractive_1;\nconst TUI = 'tui_interactive_';\n/**\n * The most basic class for interactive components\n */\n\nlet AbstractTuiInteractive = AbstractTuiInteractive_1 = class AbstractTuiInteractive {\n  constructor() {\n    this.pseudoHovered = null;\n    this.pseudoPressed = null;\n    this.pseudoFocused = null;\n    /**\n     * Determines if component is focusable with keyboard.\n     */\n\n    this.focusable = true;\n    this.nativeId = '';\n    /**\n     * Emits 'true' on focus and 'false' on blur.\n     */\n\n    this.focusedChange = new EventEmitter();\n    /** @deprecated use `tuiPressedChange` directive */\n\n    this.pressedChange = new EventEmitter();\n    /** @deprecated use `tuiHoveredChange` directive */\n\n    this.hoveredChange = new EventEmitter();\n    this.focusVisibleChange = new EventEmitter();\n    /** @deprecated use `tuiHoveredChange` directive */\n\n    this.hovered = false;\n    /** @deprecated use `tuiPressedChange` directive */\n\n    this.pressed = false;\n    this.focusVisible = false;\n    this.autoIdString = `${TUI}${AbstractTuiInteractive_1.autoId++}${Date.now()}`;\n  }\n\n  get computedDisabled() {\n    return this.disabled;\n  }\n  /** @deprecated */\n\n\n  get computedHovered() {\n    var _a;\n\n    return !this.computedDisabled && ((_a = this.pseudoHovered) !== null && _a !== void 0 ? _a : this.hovered);\n  }\n  /** @deprecated */\n\n\n  get computedPressed() {\n    var _a;\n\n    return !this.computedDisabled && ((_a = this.pseudoPressed) !== null && _a !== void 0 ? _a : this.pressed);\n  }\n\n  get computedFocusable() {\n    return !this.computedDisabled && (this.focusable || this.focused);\n  }\n\n  get computedFocused() {\n    var _a;\n\n    return !this.computedDisabled && ((_a = this.pseudoFocused) !== null && _a !== void 0 ? _a : this.focused);\n  }\n\n  get computedFocusVisible() {\n    var _a;\n\n    return !this.computedDisabled && ((_a = this.pseudoFocused) !== null && _a !== void 0 ? _a : this.focusVisible);\n  } // TODO: Consider removing since native input is exposed\n\n\n  get id() {\n    return this.nativeId ? this.nativeId : this.autoIdString;\n  }\n  /** @deprecated */\n\n\n  updateHovered(hovered) {\n    if (this.hovered === hovered) {\n      return;\n    }\n\n    this.hovered = hovered;\n    this.hoveredChange.emit(hovered);\n  }\n  /** @deprecated */\n\n\n  updatePressed(pressed) {\n    if (this.pressed === pressed) {\n      return;\n    }\n\n    this.pressed = pressed;\n    this.pressedChange.emit(pressed);\n  }\n\n  updateFocused(focused) {\n    this.focusedChange.emit(focused);\n  }\n\n  updateFocusVisible(focusVisible) {\n    if (this.focusVisible === focusVisible) {\n      return;\n    }\n\n    this.focusVisible = focusVisible;\n    this.focusVisibleChange.emit(focusVisible);\n  }\n\n};\n\nAbstractTuiInteractive.ɵfac = function AbstractTuiInteractive_Factory(t) {\n  return new (t || AbstractTuiInteractive)();\n};\n\nAbstractTuiInteractive.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n  type: AbstractTuiInteractive,\n  hostVars: 10,\n  hostBindings: function AbstractTuiInteractive_HostBindings(rf, ctx) {\n    if (rf & 2) {\n      ɵngcc0.ɵɵclassProp(\"_disabled\", ctx.computedDisabled)(\"_hovered\", ctx.computedHovered)(\"_pressed\", ctx.computedPressed)(\"_focused\", ctx.computedFocused)(\"_focus-visible\", ctx.computedFocusVisible);\n    }\n  },\n  inputs: {\n    pseudoHovered: \"pseudoHovered\",\n    pseudoPressed: \"pseudoPressed\",\n    pseudoFocused: \"pseudoFocused\",\n    focusable: \"focusable\",\n    nativeId: \"nativeId\"\n  },\n  outputs: {\n    focusedChange: \"focusedChange\",\n    pressedChange: \"pressedChange\",\n    hoveredChange: \"hoveredChange\",\n    focusVisibleChange: \"focusVisibleChange\"\n  }\n});\nAbstractTuiInteractive.autoId = 0;\n\n__decorate([Input(), tuiDefaultProp()], AbstractTuiInteractive.prototype, \"pseudoHovered\", void 0);\n\n__decorate([Input(), tuiDefaultProp()], AbstractTuiInteractive.prototype, \"pseudoPressed\", void 0);\n\n__decorate([Input(), tuiDefaultProp()], AbstractTuiInteractive.prototype, \"pseudoFocused\", void 0);\n\n__decorate([Input(), tuiDefaultProp()], AbstractTuiInteractive.prototype, \"focusable\", void 0);\n\n__decorate([Input(), tuiDefaultProp()], AbstractTuiInteractive.prototype, \"nativeId\", void 0);\n\n__decorate([Output()], AbstractTuiInteractive.prototype, \"focusedChange\", void 0);\n\n__decorate([Output()], AbstractTuiInteractive.prototype, \"pressedChange\", void 0);\n\n__decorate([Output()], AbstractTuiInteractive.prototype, \"hoveredChange\", void 0);\n\n__decorate([Output()], AbstractTuiInteractive.prototype, \"focusVisibleChange\", void 0);\n\n__decorate([HostBinding('class._disabled')], AbstractTuiInteractive.prototype, \"computedDisabled\", null);\n\n__decorate([HostBinding('class._hovered')], AbstractTuiInteractive.prototype, \"computedHovered\", null);\n\n__decorate([HostBinding('class._pressed')], AbstractTuiInteractive.prototype, \"computedPressed\", null);\n\n__decorate([HostBinding('class._focused')], AbstractTuiInteractive.prototype, \"computedFocused\", null);\n\n__decorate([HostBinding('class._focus-visible')], AbstractTuiInteractive.prototype, \"computedFocusVisible\", null);\n/**\n * Basic ControlValueAccessor class to build form components upon\n */\n\n\nlet AbstractTuiControl = /*#__PURE__*/(() => {\n  let AbstractTuiControl = class AbstractTuiControl extends AbstractTuiInteractive {\n    constructor(ngControl, changeDetectorRef, valueTransformer) {\n      super();\n      this.ngControl = ngControl;\n      this.changeDetectorRef = changeDetectorRef;\n      this.valueTransformer = valueTransformer;\n      this.onTouched = EMPTY_FUNCTION;\n      this.onChange = EMPTY_FUNCTION;\n      this.fallbackValue = this.getFallbackValue();\n      this.destroy$ = new Subject();\n      this.readOnly = false;\n      this.pseudoInvalid = null;\n\n      if (this.ngControl === null) {\n        tuiAssert.assert(false, `NgControl not injected in ${this.constructor.name}!\\n`, 'Use [(ngModel)] or [formControl] or formControlName for correct work.');\n      } else {\n        this.ngControl.valueAccessor = this;\n      }\n    }\n\n    get computedInvalid() {\n      return this.interactive && (this.pseudoInvalid !== null ? this.pseudoInvalid : this.touched && this.invalid);\n    }\n\n    get value() {\n      var _a;\n\n      return (_a = this.previousInternalValue) !== null && _a !== void 0 ? _a : this.fallbackValue;\n    }\n\n    get safeCurrentValue() {\n      var _a;\n\n      return (_a = this.rawValue) !== null && _a !== void 0 ? _a : this.fallbackValue;\n    }\n\n    get invalid() {\n      return this.safeNgControlData(({\n        invalid\n      }) => invalid, false);\n    }\n\n    get valid() {\n      return this.safeNgControlData(({\n        valid\n      }) => valid, false);\n    }\n\n    get touched() {\n      return this.safeNgControlData(({\n        touched\n      }) => touched, false);\n    }\n\n    get disabled() {\n      return this.safeNgControlData(({\n        disabled\n      }) => disabled, false);\n    }\n\n    get interactive() {\n      return !this.readOnly && !this.computedDisabled;\n    }\n\n    get control() {\n      return this.safeNgControlData(({\n        control\n      }) => control, null);\n    }\n\n    get computedName() {\n      var _a, _b;\n\n      return (_b = (_a = this.controlName) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : null;\n    }\n\n    get controlName() {\n      var _a, _b, _c;\n\n      return (_c = (_b = (_a = this.ngControl) === null || _a === void 0 ? void 0 : _a.name) === null || _b === void 0 ? void 0 : _b.toString()) !== null && _c !== void 0 ? _c : null;\n    }\n\n    get rawValue() {\n      const {\n        ngControl\n      } = this;\n\n      if (ngControl === null) {\n        return undefined;\n      }\n\n      const controlValue = ngControl instanceof NgModel && this.previousInternalValue === undefined ? ngControl.viewModel : ngControl.value;\n      return this.fromControlValue(controlValue);\n    }\n\n    ngOnInit() {\n      var _a, _b;\n\n      if (!((_a = this.ngControl) === null || _a === void 0 ? void 0 : _a.valueChanges) || !((_b = this.ngControl) === null || _b === void 0 ? void 0 : _b.statusChanges)) {\n        return;\n      }\n\n      merge(this.ngControl.valueChanges, this.ngControl.statusChanges).pipe(takeUntil(this.destroy$)).subscribe(() => this.refreshLocalValue(this.safeCurrentValue));\n    }\n\n    ngOnDestroy() {\n      this.destroy$.next();\n      this.destroy$.complete();\n    }\n\n    checkControlUpdate() {\n      this.changeDetectorRef.markForCheck();\n    }\n\n    registerOnChange(onChange) {\n      this.onChange = componentValue => {\n        onChange(this.toControlValue(componentValue));\n      };\n    }\n\n    registerOnTouched(onTouched) {\n      this.onTouched = onTouched;\n    }\n\n    setDisabledState() {\n      this.checkControlUpdate();\n    }\n\n    writeValue(value) {\n      const controlValue = this.ngControl instanceof NgModel && this.previousInternalValue === undefined ? this.ngControl.model : value;\n      this.refreshLocalValue(this.fromControlValue(controlValue));\n    }\n\n    updateFocused(focused) {\n      if (!focused) {\n        this.controlMarkAsTouched();\n      }\n\n      super.updateFocused(focused);\n    }\n\n    updateValue(value) {\n      if (this.disabled || this.valueIdenticalComparator(this.value, value)) {\n        return;\n      }\n\n      this.previousInternalValue = value;\n      this.controlSetValue(value);\n    }\n\n    valueIdenticalComparator(oldValue, newValue) {\n      return oldValue === newValue;\n    }\n\n    safeNgControlData(extractor, defaultFieldValue) {\n      var _a;\n\n      return (_a = this.ngControl && extractor(this.ngControl)) !== null && _a !== void 0 ? _a : defaultFieldValue;\n    }\n\n    controlMarkAsTouched() {\n      this.onTouched();\n      this.checkControlUpdate();\n    }\n\n    controlSetValue(value) {\n      this.onChange(value);\n      this.checkControlUpdate();\n    }\n\n    refreshLocalValue(value) {\n      this.previousInternalValue = value;\n      this.checkControlUpdate();\n    }\n\n    fromControlValue(controlValue) {\n      return this.valueTransformer ? this.valueTransformer.fromControlValue(controlValue) : controlValue;\n    }\n\n    toControlValue(componentValue) {\n      return this.valueTransformer ? this.valueTransformer.toControlValue(componentValue) : componentValue;\n    }\n\n  };\n\n  AbstractTuiControl.ɵfac = function AbstractTuiControl_Factory(t) {\n    return new (t || AbstractTuiControl)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(undefined));\n  };\n\n  AbstractTuiControl.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: AbstractTuiControl,\n    hostVars: 4,\n    hostBindings: function AbstractTuiControl_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        ɵngcc0.ɵɵclassProp(\"_readonly\", ctx.readOnly)(\"_invalid\", ctx.computedInvalid);\n      }\n    },\n    inputs: {\n      readOnly: \"readOnly\",\n      pseudoInvalid: \"pseudoInvalid\"\n    },\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature]\n  });\n\n  __decorate([Input(), HostBinding('class._readonly'), tuiDefaultProp()], AbstractTuiControl.prototype, \"readOnly\", void 0);\n\n  __decorate([Input(), tuiDefaultProp()], AbstractTuiControl.prototype, \"pseudoInvalid\", void 0);\n\n  __decorate([HostBinding('class._invalid')], AbstractTuiControl.prototype, \"computedInvalid\", null);\n\n  return AbstractTuiControl;\n})();\nlet TuiController = /*#__PURE__*/(() => {\n  class TuiController {\n    constructor() {\n      this.change$ = new Subject();\n    }\n\n    ngOnChanges() {\n      this.change$.next();\n    }\n\n  }\n\n  TuiController.ɵfac = function TuiController_Factory(t) {\n    return new (t || TuiController)();\n  };\n\n  TuiController.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: TuiController,\n    features: [ɵngcc0.ɵɵNgOnChangesFeature]\n  });\n  return TuiController;\n})();\nlet AbstractTuiDialogService = /*#__PURE__*/(() => {\n  let AbstractTuiDialogService = class AbstractTuiDialogService extends Observable {\n    constructor(idService) {\n      super(observer => this.dialogs$.subscribe(observer));\n      this.idService = idService;\n      this.dialogs$ = new BehaviorSubject([]);\n    }\n\n    open(content, options = {}) {\n      return new Observable(observer => {\n        const completeWith = result => {\n          observer.next(result);\n          observer.complete();\n        };\n\n        const dialog = Object.assign(Object.assign(Object.assign({}, this.defaultOptions), options), {\n          content,\n          completeWith,\n          $implicit: observer,\n          component: this.component,\n          createdAt: Date.now(),\n          id: this.idService.generate()\n        });\n        this.dialogs$.next([...this.dialogs$.value, dialog]);\n        return () => {\n          this.dialogs$.next(this.dialogs$.value.filter(item => item !== dialog));\n        };\n      });\n    }\n\n  };\n\n  AbstractTuiDialogService.ɵfac = function AbstractTuiDialogService_Factory(t) {\n    return new (t || AbstractTuiDialogService)(ɵngcc0.ɵɵinject(TuiIdService));\n  };\n\n  AbstractTuiDialogService.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: AbstractTuiDialogService,\n    factory: function (t) {\n      return AbstractTuiDialogService.ɵfac(t);\n    }\n  });\n  AbstractTuiDialogService = __decorate([__param(0, Inject(TuiIdService))], AbstractTuiDialogService);\n  return AbstractTuiDialogService;\n})();\nlet AbstractTuiDialogDirective = /*#__PURE__*/(() => {\n  let AbstractTuiDialogDirective = class AbstractTuiDialogDirective extends PolymorpheusTemplate {\n    constructor(templateRef, changeDetectorRef, service) {\n      super(templateRef, changeDetectorRef);\n      this.service = service;\n      this.open$ = new Subject();\n      this.options = {};\n      this.openChange = this.open$.pipe(switchMap(open => open ? this.service.open(this, this.options).pipe(ignoreElements(), endWith(false)) : EMPTY));\n    }\n\n    set open(open) {\n      this.open$.next(open);\n    }\n\n  };\n\n  AbstractTuiDialogDirective.ɵfac = function AbstractTuiDialogDirective_Factory(t) {\n    return new (t || AbstractTuiDialogDirective)(ɵngcc0.ɵɵdirectiveInject(TemplateRef), ɵngcc0.ɵɵdirectiveInject(ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(AbstractTuiDialogService));\n  };\n\n  AbstractTuiDialogDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: AbstractTuiDialogDirective,\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature]\n  });\n  AbstractTuiDialogDirective = __decorate([__param(0, Inject(TemplateRef)), __param(1, Inject(ChangeDetectorRef)), __param(2, Inject(AbstractTuiDialogService))], AbstractTuiDialogDirective);\n  return AbstractTuiDialogDirective;\n})();\nlet AbstractTuiMultipleControl = /*#__PURE__*/(() => {\n  let AbstractTuiMultipleControl = class AbstractTuiMultipleControl extends AbstractTuiControl {\n    clear() {\n      this.updateValue([]);\n    }\n\n    getFallbackValue() {\n      return [];\n    }\n\n  };\n\n  AbstractTuiMultipleControl.ɵfac = /*@__PURE__*/function () {\n    let ɵAbstractTuiMultipleControl_BaseFactory;\n    return function AbstractTuiMultipleControl_Factory(t) {\n      return (ɵAbstractTuiMultipleControl_BaseFactory || (ɵAbstractTuiMultipleControl_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(AbstractTuiMultipleControl)))(t || AbstractTuiMultipleControl);\n    };\n  }();\n\n  AbstractTuiMultipleControl.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: AbstractTuiMultipleControl,\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature]\n  });\n  return AbstractTuiMultipleControl;\n})();\nlet AbstractTuiNullableControl = /*#__PURE__*/(() => {\n  let AbstractTuiNullableControl = class AbstractTuiNullableControl extends AbstractTuiControl {\n    getFallbackValue() {\n      return null;\n    }\n\n  };\n\n  AbstractTuiNullableControl.ɵfac = /*@__PURE__*/function () {\n    let ɵAbstractTuiNullableControl_BaseFactory;\n    return function AbstractTuiNullableControl_Factory(t) {\n      return (ɵAbstractTuiNullableControl_BaseFactory || (ɵAbstractTuiNullableControl_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(AbstractTuiNullableControl)))(t || AbstractTuiNullableControl);\n    };\n  }();\n\n  AbstractTuiNullableControl.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: AbstractTuiNullableControl,\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature]\n  });\n  /**\n   * Abstract service for displaying portals\n   */\n\n  return AbstractTuiNullableControl;\n})();\nlet AbstractTuiPortalService = /*#__PURE__*/(() => {\n  let AbstractTuiPortalService = class AbstractTuiPortalService {\n    get safeHost() {\n      if (!this.host) {\n        throw new TuiNoHostException();\n      }\n\n      return this.host;\n    }\n\n    attach(host) {\n      this.host = host;\n    }\n\n    add(componentFactory, injector) {\n      return this.safeHost.addComponentChild(componentFactory, injector);\n    }\n\n    remove({\n      hostView\n    }) {\n      hostView.destroy();\n    }\n\n    addTemplate(templateRef, context) {\n      return this.safeHost.addTemplateChild(templateRef, context);\n    }\n\n    removeTemplate(viewRef) {\n      viewRef.destroy();\n    }\n\n  };\n\n  AbstractTuiPortalService.ɵfac = function AbstractTuiPortalService_Factory(t) {\n    return new (t || AbstractTuiPortalService)();\n  };\n\n  AbstractTuiPortalService.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: AbstractTuiPortalService,\n    factory: function (t) {\n      return AbstractTuiPortalService.ɵfac(t);\n    }\n  });\n  return AbstractTuiPortalService;\n})();\nvar AbstractTuiPortalHostComponent_1;\n/**\n * Abstract class for host element for dynamically created portals.\n */\n\nlet AbstractTuiPortalHostComponent = AbstractTuiPortalHostComponent_1 = class AbstractTuiPortalHostComponent {\n  constructor(elementRef, portalService) {\n    this.elementRef = elementRef;\n    portalService.attach(this);\n  }\n\n  get clientRect() {\n    return this.elementRef.nativeElement.getBoundingClientRect();\n  }\n\n  addComponentChild(componentFactory, injector) {\n    return this.viewContainerRef.createComponent(componentFactory, undefined, Injector.create({\n      parent: injector,\n      providers: [{\n        provide: AbstractTuiPortalHostComponent_1,\n        useValue: this\n      }]\n    }));\n  }\n\n  addTemplateChild(templateRef, context) {\n    return this.viewContainerRef.createEmbeddedView(templateRef, context);\n  }\n\n};\n\nAbstractTuiPortalHostComponent.ɵfac = function AbstractTuiPortalHostComponent_Factory(t) {\n  return new (t || AbstractTuiPortalHostComponent)(ɵngcc0.ɵɵdirectiveInject(ElementRef), ɵngcc0.ɵɵdirectiveInject(AbstractTuiPortalService));\n};\n\nAbstractTuiPortalHostComponent.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n  type: AbstractTuiPortalHostComponent,\n  viewQuery: function AbstractTuiPortalHostComponent_Query(rf, ctx) {\n    if (rf & 1) {\n      ɵngcc0.ɵɵviewQuery(_c0, 5, ViewContainerRef);\n    }\n\n    if (rf & 2) {\n      let _t;\n\n      ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.viewContainerRef = _t.first);\n    }\n  }\n});\n\nAbstractTuiPortalHostComponent.ctorParameters = () => [{\n  type: ElementRef,\n  decorators: [{\n    type: Inject,\n    args: [ElementRef]\n  }]\n}, {\n  type: AbstractTuiPortalService,\n  decorators: [{\n    type: Inject,\n    args: [AbstractTuiPortalService]\n  }]\n}];\n\n__decorate([ViewChild('viewContainer', {\n  read: ViewContainerRef\n})], AbstractTuiPortalHostComponent.prototype, \"viewContainerRef\", void 0);\n\nAbstractTuiPortalHostComponent = AbstractTuiPortalHostComponent_1 = __decorate([__param(0, Inject(ElementRef)), __param(1, Inject(AbstractTuiPortalService))], AbstractTuiPortalHostComponent);\nvar AbstractTuiThemeSwitcher_1;\n/**\n * Use this abstract class to create your own toggleable themes.\n * A component extending this class must have CSS variables definitions\n * and have ViewEncapsulation set to NONE. A boolean input allows to\n * switch theme on or off.\n * @dynamic\n */\n\nlet AbstractTuiThemeSwitcher = AbstractTuiThemeSwitcher_1 = class AbstractTuiThemeSwitcher {\n  constructor(documentRef) {\n    this.documentRef = documentRef;\n\n    if (this.style !== null) {\n      this.addTheme();\n      return;\n    }\n\n    const styles = this.documentRef.head.querySelectorAll('style');\n    this.constructor.style = styles[styles.length - 1];\n  }\n\n  get style() {\n    return this.constructor.style;\n  }\n\n  ngOnDestroy() {\n    this.removeTheme();\n  }\n\n  addTheme() {\n    if (this.style) {\n      this.documentRef.head.appendChild(this.style);\n    }\n  }\n\n  removeTheme() {\n    if (this.style && this.documentRef.head.contains(this.style)) {\n      this.documentRef.head.removeChild(this.style);\n    }\n  }\n\n};\n\nAbstractTuiThemeSwitcher.ɵfac = function AbstractTuiThemeSwitcher_Factory(t) {\n  return new (t || AbstractTuiThemeSwitcher)(ɵngcc0.ɵɵdirectiveInject(DOCUMENT));\n};\n\nAbstractTuiThemeSwitcher.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n  type: AbstractTuiThemeSwitcher\n});\nAbstractTuiThemeSwitcher.style = null;\n\nAbstractTuiThemeSwitcher.ctorParameters = () => [{\n  type: Document,\n  decorators: [{\n    type: Inject,\n    args: [DOCUMENT]\n  }]\n}];\n\nAbstractTuiThemeSwitcher = AbstractTuiThemeSwitcher_1 = __decorate([__param(0, Inject(DOCUMENT))], AbstractTuiThemeSwitcher);\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { AbstractTuiControl, AbstractTuiDialogDirective, AbstractTuiDialogService, AbstractTuiInteractive, AbstractTuiMultipleControl, AbstractTuiNullableControl, AbstractTuiPortalHostComponent, AbstractTuiPortalService, AbstractTuiThemeSwitcher, TuiController }; //# sourceMappingURL=taiga-ui-cdk-abstract.js.map","map":null,"metadata":{},"sourceType":"module"}