{"ast":null,"code":"import { clamp } from '@taiga-ui/cdk/utils/math';\nimport { isPresent } from '@taiga-ui/cdk/utils/miscellaneous';\nimport { tuiAssert } from '@taiga-ui/cdk/classes';\n\nfunction canScroll(element, rootElement, vertical, scrollEnd) {\n  return vertical ? canScrollVertical(element, rootElement, scrollEnd) : canScrollHorizontal(element, rootElement, scrollEnd);\n}\n\nfunction canScrollVertical(element, rootElement, scrollEnd) {\n  let currentElement = element;\n\n  while (currentElement !== rootElement.parentElement) {\n    if (Math.floor(currentElement.scrollTop) > 0 && !scrollEnd || Math.ceil(currentElement.scrollTop + currentElement.clientHeight) < currentElement.scrollHeight && scrollEnd) {\n      return true;\n    }\n\n    if (currentElement.parentElement) {\n      currentElement = currentElement.parentElement;\n    } else {\n      return false;\n    }\n  }\n\n  return false;\n}\n\nfunction canScrollHorizontal(element, rootElement, scrollEnd) {\n  let currentElement = element;\n\n  while (currentElement !== rootElement.parentElement) {\n    if (Math.floor(currentElement.scrollLeft) > 0 && !scrollEnd || Math.ceil(currentElement.scrollLeft + currentElement.clientWidth) < currentElement.scrollWidth && scrollEnd) {\n      return true;\n    }\n\n    if (currentElement.parentElement) {\n      currentElement = currentElement.parentElement;\n    } else {\n      return false;\n    }\n  }\n\n  return false;\n}\n\nfunction containsOrAfter(current, node) {\n  return current.contains(node) || !!(node.compareDocumentPosition(current) & Node.DOCUMENT_POSITION_PRECEDING);\n}\n/** @deprecated only needed for IE, remove in 3.0 */\n\n\nfunction tuiCustomEvent(name, {\n  bubbles = false,\n  cancelable = false,\n  detail = null\n} = {}, documentRef) {\n  if (typeof CustomEvent === 'function') {\n    return new CustomEvent(name, {\n      bubbles,\n      cancelable,\n      detail\n    });\n  }\n\n  const customEvent = documentRef.createEvent('CustomEvent');\n  customEvent.initCustomEvent(name, bubbles, cancelable, detail);\n  return customEvent;\n}\n/**\n * Gets actual target from open Shadow DOM if event happened within it\n */\n\n\nfunction getActualTarget(event) {\n  if ('composedPath' in event) {\n    return event.composedPath()[0];\n  }\n\n  return event.target;\n}\n\nconst DEFAULT_FORMAT = 'text/plain';\n/**\n * Gets text from data of clipboardEvent, it also works in IE and Edge browsers\n */\n\nfunction getClipboardDataText(event, format = DEFAULT_FORMAT) {\n  return 'clipboardData' in event && event.clipboardData !== null ? event.clipboardData.getData(format) || event.clipboardData.getData(DEFAULT_FORMAT) : event.target.ownerDocument.defaultView.clipboardData.getData('text');\n}\n/**\n * Gets closest element by selector i.e. {@link Element.closest}\n * @deprecated only needed for IE, remove in 3.0\n */\n\n\nfunction getClosestElement(element, selector) {\n  const closest = Element.prototype.closest;\n\n  if (closest) {\n    return closest.call(element, selector);\n  }\n\n  const matchesSelector = Element.prototype.matches || Element.prototype.msMatchesSelector;\n\n  do {\n    if (matchesSelector.call(element, selector)) {\n      return element;\n    }\n\n    element = element.parentElement;\n  } while (element !== null);\n\n  return null;\n}\n\nfunction getDocumentOrShadowRoot(node) {\n  return 'getRootNode' in node && node.isConnected ? node.getRootNode() : node.ownerDocument;\n}\n/**\n * Returns array of Elements covering edges of given element or null if at least one edge middle point is visible\n *\n * CAUTION: Empty array means element if offscreen i.e. covered by no elements, rather than not covered\n */\n\n\nfunction getElementObscurers(element) {\n  const {\n    ownerDocument\n  } = element;\n\n  if (!ownerDocument || !ownerDocument.defaultView) {\n    return null;\n  }\n\n  const {\n    innerWidth,\n    innerHeight\n  } = ownerDocument.defaultView;\n  const documentRef = getDocumentOrShadowRoot(element);\n  const rect = element.getBoundingClientRect();\n  const left = clamp(Math.round(rect.left) + 2, 0, innerWidth);\n  const top = clamp(Math.round(rect.top) + 2, 0, innerHeight);\n  const right = clamp(Math.round(rect.right) - 2, 0, innerWidth);\n  const bottom = clamp(Math.round(rect.bottom) - 2, 0, innerHeight);\n  const horizontalMiddle = clamp(Math.round(rect.left + rect.width / 2), 0, innerWidth);\n  const verticalMiddle = clamp(Math.round(rect.top + rect.height / 2), 0, innerHeight);\n  const elements = [documentRef.elementFromPoint(horizontalMiddle, top), documentRef.elementFromPoint(horizontalMiddle, bottom), documentRef.elementFromPoint(left, verticalMiddle), documentRef.elementFromPoint(right, verticalMiddle)];\n  const nonNull = elements.filter(isPresent);\n\n  if (!nonNull.length) {\n    return nonNull;\n  }\n\n  const filtered = nonNull.filter(el => !element.contains(el));\n  return filtered.length === 4 ? filtered : null;\n}\n/**\n * Calculates offset for an element relative to it's parent several levels above\n *\n * @param host parent element\n * @param element\n * @return object with offsetTop and offsetLeft number properties\n */\n\n\nfunction getElementOffset(host, element) {\n  tuiAssert.assert(host.contains(element), 'Host must contain element');\n  let {\n    offsetTop,\n    offsetLeft,\n    offsetParent\n  } = element; // TODO: iframe warning\n\n  while (offsetParent && offsetParent instanceof HTMLElement && offsetParent !== host) {\n    offsetTop += offsetParent.offsetTop;\n    offsetLeft += offsetParent.offsetLeft;\n    offsetParent = offsetParent.offsetParent;\n  }\n\n  return {\n    offsetTop,\n    offsetLeft\n  };\n}\n/**\n * Finds nearest parent with scroll in it\n *\n * @param element initial element\n * @param vertical flag for orientation of scroll\n */\n\n\nfunction getScrollParent(element, vertical = true) {\n  if (element === null) {\n    return null;\n  }\n\n  if (vertical && element.scrollHeight > element.clientHeight) {\n    return element;\n  }\n\n  if (!vertical && element.scrollWidth > element.clientWidth) {\n    return element;\n  }\n\n  return getScrollParent(element.parentElement, vertical);\n}\n\nfunction isCurrentTarget({\n  target,\n  currentTarget\n}) {\n  return target === currentTarget;\n}\n/**\n * Checks if an app is running inside <iframe /> tag\n */\n\n\nfunction isInsideIframe(windowRef) {\n  return windowRef.parent !== windowRef;\n}\n/**\n * Checks if node is inside a specific selector\n *\n * @param node\n * @param selector\n * @return true if node is inside a particular selector\n */\n\n\nfunction isNodeIn(node, selector) {\n  return node.nodeType === Node.TEXT_NODE ? !!node.parentElement && !!getClosestElement(node.parentElement, selector) : node.nodeType === Node.ELEMENT_NODE && !!getClosestElement(node, selector);\n}\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { canScroll, containsOrAfter, getActualTarget, getClipboardDataText, getClosestElement, getDocumentOrShadowRoot, getElementObscurers, getElementOffset, getScrollParent, isCurrentTarget, isInsideIframe, isNodeIn, tuiCustomEvent }; //# sourceMappingURL=taiga-ui-cdk-utils-dom.js.map","map":null,"metadata":{},"sourceType":"module"}