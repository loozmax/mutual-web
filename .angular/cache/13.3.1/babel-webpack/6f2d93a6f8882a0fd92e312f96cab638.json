{"ast":null,"code":"import { __decorate, __param } from 'tslib';\nimport { ElementRef, Inject, NgZone, Input, HostBinding, Directive, NgModule } from '@angular/core';\nimport { typedFromEvent, tuiZonefree } from '@taiga-ui/cdk/observables';\nimport { TuiDestroyService } from '@taiga-ui/cdk/services';\nimport { getScrollParent, canScroll } from '@taiga-ui/cdk/utils/dom';\nimport { Observable } from 'rxjs';\nimport { filter, takeUntil, switchMap, tap } from 'rxjs/operators';\n/**\n * Directive to isolate scrolling, i.e. prevent body scroll behind modal dialog\n * @dynamic\n */\n\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from 'rxjs';\nlet TuiOverscrollDirective = /*#__PURE__*/(() => {\n  let TuiOverscrollDirective = class TuiOverscrollDirective {\n    constructor({\n      nativeElement\n    }, ngZone, destroy$) {\n      this.mode = 'scroll';\n      typedFromEvent(nativeElement, 'wheel', {\n        passive: false\n      }).pipe(filter(() => this.enabled), takeUntil(destroy$), tuiZonefree(ngZone)).subscribe(event => {\n        this.processEvent(event, !!event.deltaY, event.deltaY ? event.deltaY < 0 : event.deltaX < 0);\n      });\n      typedFromEvent(nativeElement, 'touchstart', {\n        passive: true\n      }).pipe(switchMap(({\n        touches\n      }) => {\n        let {\n          clientX,\n          clientY\n        } = touches[0];\n        let deltaX = 0;\n        let deltaY = 0;\n        let vertical;\n        return typedFromEvent(nativeElement, 'touchmove', {\n          passive: false\n        }).pipe(filter(() => this.enabled), tap(event => {\n          // We have to have it in tap instead of subscribe due to variables in closure\n          const changedTouch = event.changedTouches[0];\n          deltaX = clientX - changedTouch.clientX;\n          deltaY = clientY - changedTouch.clientY;\n          clientX = changedTouch.clientX;\n          clientY = changedTouch.clientY;\n\n          if (vertical === undefined) {\n            vertical = Math.abs(deltaY) > Math.abs(deltaX);\n          }\n\n          this.processEvent(event, vertical, vertical ? deltaY < 0 : deltaX < 0);\n        }));\n      }), takeUntil(destroy$), tuiZonefree(ngZone)).subscribe();\n    }\n\n    get enabled() {\n      return this.mode !== 'none';\n    }\n\n    get overscrollBehavior() {\n      return this.enabled ? 'contain' : null;\n    }\n\n    processEvent(event, vertical, negative) {\n      const {\n        target,\n        currentTarget,\n        cancelable\n      } = event; // TODO: iframe warning\n\n      if (!cancelable || !(target instanceof Element)) {\n        return;\n      } // This is all what's needed in Chrome/Firefox thanks to CSS overscroll-behavior\n\n\n      if (this.mode === 'all' && (vertical && !currentTarget.contains(getScrollParent(target)) || !vertical && !currentTarget.contains(getScrollParent(target, false)))) {\n        event.preventDefault();\n        return;\n      } // This is Safari/IE/Edge fallback\n\n\n      if (vertical && (negative && !canScroll(target, currentTarget, true, false) || !negative && !canScroll(target, currentTarget, true, true))) {\n        event.preventDefault();\n        return;\n      }\n\n      if (!vertical && (negative && !canScroll(target, currentTarget, false, false) || !negative && !canScroll(target, currentTarget, false, true))) {\n        event.preventDefault();\n      }\n    }\n\n  };\n\n  TuiOverscrollDirective.ɵfac = function TuiOverscrollDirective_Factory(t) {\n    return new (t || TuiOverscrollDirective)(ɵngcc0.ɵɵdirectiveInject(ElementRef), ɵngcc0.ɵɵdirectiveInject(NgZone), ɵngcc0.ɵɵdirectiveInject(TuiDestroyService));\n  };\n\n  TuiOverscrollDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: TuiOverscrollDirective,\n    selectors: [[\"\", \"tuiOverscroll\", \"\"]],\n    hostVars: 2,\n    hostBindings: function TuiOverscrollDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        ɵngcc0.ɵɵstyleProp(\"overscroll-behavior\", ctx.overscrollBehavior);\n      }\n    },\n    inputs: {\n      mode: [\"tuiOverscroll\", \"mode\"]\n    },\n    features: [ɵngcc0.ɵɵProvidersFeature([TuiDestroyService])]\n  });\n\n  __decorate([Input('tuiOverscroll')], TuiOverscrollDirective.prototype, \"mode\", void 0);\n\n  __decorate([HostBinding('style.overscrollBehavior')], TuiOverscrollDirective.prototype, \"overscrollBehavior\", null);\n\n  TuiOverscrollDirective = __decorate([__param(0, Inject(ElementRef)), __param(1, Inject(NgZone)), __param(2, Inject(TuiDestroyService))], TuiOverscrollDirective);\n  return TuiOverscrollDirective;\n})();\nlet TuiOverscrollModule = /*#__PURE__*/(() => {\n  let TuiOverscrollModule = class TuiOverscrollModule {};\n\n  TuiOverscrollModule.ɵfac = function TuiOverscrollModule_Factory(t) {\n    return new (t || TuiOverscrollModule)();\n  };\n\n  TuiOverscrollModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: TuiOverscrollModule\n  });\n  TuiOverscrollModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({});\n  return TuiOverscrollModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(TuiOverscrollModule, {\n    declarations: [TuiOverscrollDirective],\n    exports: [TuiOverscrollDirective]\n  });\n})();\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { TuiOverscrollDirective, TuiOverscrollModule }; //# sourceMappingURL=taiga-ui-cdk-directives-overscroll.js.map","map":null,"metadata":{},"sourceType":"module"}