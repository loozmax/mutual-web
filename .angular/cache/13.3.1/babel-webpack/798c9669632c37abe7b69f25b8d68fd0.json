{"ast":null,"code":"import { TuiDay, DATE_FILLER_LENGTH, DATE_RANGE_FILLER_LENGTH, TuiDayRange, RANGE_SEPARATOR_CHAR, tuiAssert, CHAR_NO_BREAK_SPACE, CHAR_EN_DASH } from '@taiga-ui/cdk';\nimport { MAX_TIME_VALUES, DATE_TIME_SEPARATOR } from '@taiga-ui/kit/constants';\nimport { TUI_DIGIT_REGEXP } from '@taiga-ui/core';\n\nfunction normalizeDateValue(dateValue, {\n  value,\n  min,\n  max,\n  dateFormat,\n  dateSeparator\n}) {\n  return value && value.toString(dateFormat, dateSeparator) === dateValue ? dateValue : TuiDay.normalizeParse(dateValue, dateFormat).dayLimit(min, max).toString(dateFormat, dateSeparator);\n}\n\nfunction tuiCreateAutoCorrectedDatePipe(config) {\n  return value => {\n    if (value.length !== DATE_FILLER_LENGTH) {\n      return {\n        value\n      };\n    }\n\n    return {\n      value: normalizeDateValue(value, config)\n    };\n  };\n}\n\nfunction parseWithLimit(value, config) {\n  return TuiDay.normalizeParse(value.slice(0, DATE_FILLER_LENGTH), config.dateFormat).dayLimit(config.min, config.max);\n}\n\nfunction processRawValue(value, config) {\n  const {\n    dateFormat,\n    dateSeparator\n  } = config;\n\n  switch (value.length) {\n    case DATE_FILLER_LENGTH:\n      return parseWithLimit(value, config).toString(dateFormat, dateSeparator);\n\n    case DATE_FILLER_LENGTH + RANGE_SEPARATOR_CHAR.length:\n      return parseWithLimit(value, config).toString(dateFormat, dateSeparator) + RANGE_SEPARATOR_CHAR;\n\n    case DATE_RANGE_FILLER_LENGTH:\n      return config.value && config.value.toString(dateFormat, dateSeparator) === value ? value : TuiDayRange.sort(parseWithLimit(value.slice(0, DATE_FILLER_LENGTH), config), parseWithLimit(value.slice(DATE_FILLER_LENGTH + RANGE_SEPARATOR_CHAR.length), config)).toString(dateFormat, dateSeparator);\n\n    default:\n      return value;\n  }\n}\n/**\n * Normalizes date in formatted string\n *\n * Normalizes when:\n *\n * 1. It is a single date\n * 2. It is a single date and a separator\n * 3. It is two dates and a separator between them\n *\n * In **other** cases, the value does not change.\n *\n * @param config with min and max date\n * @return mask pipe handler that handles `min` and `max`\n */\n\n\nfunction tuiCreateAutoCorrectedDateRangePipe(config) {\n  return value => ({\n    value: processRawValue(value, config)\n  });\n}\n/**\n * Adjusts the entered time by omitting only suitable values for hours and minutes\n * @returns time as a string\n */\n\n\nfunction tuiCreateAutoCorrectedTimePipe(timeMode = 'HH:MM', maxValues = {}) {\n  const timeFormatArray = ['HH', 'MM', 'SS', 'MS'];\n  const safeValues = Object.assign(Object.assign({}, MAX_TIME_VALUES), maxValues);\n  return conformedValue => {\n    const indexesOfPipedChars = [];\n    const conformedValueArr = conformedValue.split('');\n    timeFormatArray.forEach(format => {\n      const position = timeMode.indexOf(format);\n      const maxFirstDigit = parseInt(String(safeValues[format]).substr(0, 1), 10);\n\n      if (parseInt(conformedValueArr[position], 10) > maxFirstDigit) {\n        conformedValueArr[position + 1] = conformedValueArr[position];\n        conformedValueArr[position] = '0';\n        indexesOfPipedChars.push(position);\n      }\n    });\n    const isInvalid = timeFormatArray.some(format => parseInt(conformedValue.substr(timeMode.indexOf(format), 2), 10) > safeValues[format]);\n    return isInvalid ? false : {\n      value: conformedValueArr.join(''),\n      indexesOfPipedChars\n    };\n  };\n}\n\nfunction tuiCreateAutoCorrectedDateTimePipe(configs) {\n  const timePipe = tuiCreateAutoCorrectedTimePipe(configs.timeMode);\n  return value => {\n    if (value.length < DATE_FILLER_LENGTH) {\n      return {\n        value\n      };\n    }\n\n    const [date, time] = value.split(DATE_TIME_SEPARATOR);\n    const formattedDate = normalizeDateValue(date, configs);\n\n    if (!time) {\n      return {\n        value: formattedDate\n      };\n    }\n\n    const pipedTime = timePipe(time, {});\n\n    if (!pipedTime || typeof pipedTime === 'string') {\n      return false;\n    }\n\n    return {\n      value: `${formattedDate}${DATE_TIME_SEPARATOR}${pipedTime.value}`,\n      indexesOfPipedChars: pipedTime.indexesOfPipedChars ? pipedTime.indexesOfPipedChars.map(i => i + date.length + 2) : undefined\n    };\n  };\n}\n\nconst TWO_DIGITS = Array(2).fill(TUI_DIGIT_REGEXP);\nconst FOUR_DIGITS = Array(4).fill(TUI_DIGIT_REGEXP);\n\nfunction tuiCreateDateMask(mode, separator) {\n  tuiAssert.assert(separator.length === 1, 'Separator should consist of only 1 symbol');\n\n  switch (mode) {\n    case 'YMD':\n      return [...FOUR_DIGITS, separator, ...TWO_DIGITS, separator, ...TWO_DIGITS];\n\n    case 'MDY':\n    case 'DMY':\n    default:\n      return [...TWO_DIGITS, separator, ...TWO_DIGITS, separator, ...FOUR_DIGITS];\n  }\n}\n\nfunction tuiCreateDateRangeMask(dateMode, dateSeparator) {\n  tuiAssert.assert(dateSeparator.length === 1, 'Separator should consist of only 1 symbol');\n  const dateMask = tuiCreateDateMask(dateMode, dateSeparator);\n  return [...dateMask, CHAR_NO_BREAK_SPACE, CHAR_EN_DASH, CHAR_NO_BREAK_SPACE, ...dateMask];\n}\n\nfunction tuiCreateTimePartMask(maxPartValue, prefix) {\n  const {\n    length\n  } = String(maxPartValue);\n  const regExp = Array(length).fill(TUI_DIGIT_REGEXP);\n\n  if (prefix) {\n    regExp.unshift(prefix);\n  }\n\n  return regExp;\n}\n\nfunction tuiCreateTimeMask(mode, maxValues = {}) {\n  const {\n    HH,\n    MM,\n    SS,\n    MS\n  } = Object.assign(Object.assign({}, MAX_TIME_VALUES), maxValues);\n  return [...tuiCreateTimePartMask(HH), ...tuiCreateTimePartMask(MM, ':'), ...(mode.includes('HH:MM:SS') ? tuiCreateTimePartMask(SS, ':') : []), ...(mode === 'HH:MM:SS.MSS' ? tuiCreateTimePartMask(MS, '.') : [])];\n}\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { normalizeDateValue, tuiCreateAutoCorrectedDatePipe, tuiCreateAutoCorrectedDateRangePipe, tuiCreateAutoCorrectedDateTimePipe, tuiCreateAutoCorrectedTimePipe, tuiCreateDateMask, tuiCreateDateRangeMask, tuiCreateTimeMask }; //# sourceMappingURL=taiga-ui-kit-utils-mask.js.map","map":null,"metadata":{},"sourceType":"module"}