{"ast":null,"code":"import { InjectionToken, inject } from '@angular/core';\nimport { CHAR_NO_BREAK_SPACE, CHAR_EN_DASH } from '@taiga-ui/cdk/constants';\nimport { tuiAssert } from '@taiga-ui/cdk/classes';\nimport { InvalidYearException, InvalidMonthException, InvalidDayException } from '@taiga-ui/cdk/exceptions';\nimport { padStart } from '@taiga-ui/cdk/utils/format';\nimport { inRange, normalizeToIntNumber } from '@taiga-ui/cdk/utils/math';\nconst DAYS_IN_WEEK = 7;\nconst DAYS_IN_NORMAL_YEAR = 365;\nconst DAYS_IN_LEAP_YEAR = 366;\nconst MONTHS_IN_YEAR = 12;\nconst MIN_DAY = 1;\nconst MIN_MONTH = 0;\nconst MAX_MONTH = 11;\nconst MIN_YEAR = 0;\nconst MAX_YEAR = 9999;\nconst RANGE_SEPARATOR_CHAR = `${CHAR_NO_BREAK_SPACE}${CHAR_EN_DASH}${CHAR_NO_BREAK_SPACE}`;\nconst MILLISECONDS_IN_SECOND = 1000;\nconst SECONDS_IN_MINUTE = 60;\nconst MINUTES_IN_HOUR = 60;\nconst HOURS_IN_DAY = 24;\nconst MILLISECONDS_IN_MINUTE = MILLISECONDS_IN_SECOND * SECONDS_IN_MINUTE;\nconst MILLISECONDS_IN_HOUR = MILLISECONDS_IN_MINUTE * MINUTES_IN_HOUR;\nconst MILLISECONDS_IN_DAY = MILLISECONDS_IN_HOUR * HOURS_IN_DAY;\n/**\n * @deprecated dont use it. See {@link TUI_DATE_FORMAT}\n * TODO: get rid of this in v3.0\n */\n\nconst TUI_DATE_FILLER = new InjectionToken('date filler for Taiga UI', {\n  factory: () => `dd.mm.yyyy`\n});\n/**\n * @deprecated dont use it\n * TODO: get rid of this in v3.0\n */\n\nconst TUI_DATE_RANGE_FILLER = new InjectionToken('date range filler for Taiga UI', {\n  factory: () => {\n    const dateFiller = inject(TUI_DATE_FILLER);\n    return `${dateFiller}${RANGE_SEPARATOR_CHAR}${dateFiller}`;\n  }\n});\n/**\n * @internal 'dd.mm.yyyy'.length\n * Used in:\n * - {@link TuiInputDateComponent}\n * - {@link TuiInputDateRangeComponent}\n * - {@link TuiInputDateTimeComponent}\n */\n\nconst DATE_FILLER_LENGTH = 10;\n/**\n * @internal\n * Used in {@link TuiInputDateRangeComponent}\n */\n\nconst DATE_RANGE_FILLER_LENGTH = 2 * DATE_FILLER_LENGTH + RANGE_SEPARATOR_CHAR.length;\nconst TUI_DATE_FORMAT = new InjectionToken('Active date format for Taiga UI', {\n  factory: () => 'DMY'\n});\nconst TUI_DATE_SEPARATOR = new InjectionToken('Date separator for Taiga UI components', {\n  factory: () => '.'\n});\n\nconst changeDateSeparator = (dateString, newDateSeparator) => dateString.replace(/[^0-9A-Za-zА-Яа-я]/gi, newDateSeparator);\n/**\n * Immutable year object\n * @nosideeffects\n */\n\n\nclass TuiYear {\n  constructor(year) {\n    this.year = year;\n    tuiAssert.assert(TuiYear.isValidYear(year));\n  }\n  /**\n   * Checks year for validity\n   */\n\n\n  static isValidYear(year) {\n    return Number.isInteger(year) && inRange(year, MIN_YEAR, MAX_YEAR + 1);\n  }\n  /**\n   * Check if passed year is a leap year\n   */\n\n\n  static isLeapYear(year) {\n    tuiAssert.assert(TuiYear.isValidYear(year));\n    return year % 400 === 0 || year % 4 === 0 && year % 100 !== 0;\n  }\n  /**\n   * Returns amount of leap years from year 0 to the passed one\n   */\n\n\n  static getAbsoluteLeapYears(year) {\n    tuiAssert.assert(TuiYear.isValidYear(year));\n    return Math.ceil(year / 400) + (Math.ceil(year / 4) - Math.ceil(year / 100));\n  }\n  /**\n   * @deprecated DONT USE IT (will be deleted soon)\n   *\n   * Returns day of week offset of the beginning of the passed year\n   *\n   * @param year\n   * @param absoluteLeapYears amount of leap years prior to the passed one\n   * @return offset in days\n   */\n\n\n  static getYearStartDaysOffset(year, absoluteLeapYears) {\n    tuiAssert.assert(TuiYear.isValidYear(year));\n    tuiAssert.assert(Number.isInteger(absoluteLeapYears));\n    tuiAssert.assert(year >= absoluteLeapYears);\n    tuiAssert.assert(absoluteLeapYears >= 0);\n    return (absoluteLeapYears * DAYS_IN_LEAP_YEAR + (year - absoluteLeapYears) * DAYS_IN_NORMAL_YEAR + 5) % DAYS_IN_WEEK;\n  }\n\n  static lengthBetween(from, to) {\n    return to.year - from.year;\n  }\n  /**\n   * Normalizes year by clamping it between min and max years\n   */\n\n\n  static normalizeYearPart(year) {\n    return normalizeToIntNumber(year, MIN_YEAR, MAX_YEAR);\n  }\n\n  get formattedYear() {\n    return padStart(String(this.year), 4, '0');\n  }\n\n  get isLeapYear() {\n    return TuiYear.isLeapYear(this.year);\n  }\n  /**\n   * Returns amount of leap years from year 0 to current\n   */\n\n\n  get absoluteLeapYears() {\n    return TuiYear.getAbsoluteLeapYears(this.year);\n  }\n  /**\n   * @deprecated DONT USE IT (will be deleted soon)\n   *\n   * Returns day of week offset of the beginning of the current year\n   */\n\n\n  get yearStartDaysOffset() {\n    return TuiYear.getYearStartDaysOffset(this.year, this.absoluteLeapYears);\n  }\n  /**\n   * Passed year is after current\n   */\n\n\n  yearBefore({\n    year\n  }) {\n    return this.year < year;\n  }\n  /**\n   * Passed year is the same or after current\n   */\n\n\n  yearSameOrBefore({\n    year\n  }) {\n    return this.year <= year;\n  }\n  /**\n   * Passed year is the same as current\n   */\n\n\n  yearSame({\n    year\n  }) {\n    return this.year === year;\n  }\n  /**\n   * Passed year is either the same of before the current\n   */\n\n\n  yearSameOrAfter({\n    year\n  }) {\n    return this.year >= year;\n  }\n  /**\n   * Passed year is before current\n   */\n\n\n  yearAfter({\n    year\n  }) {\n    return this.year > year;\n  } // TODO: Consider removing `backwards` option\n\n  /**\n   * Immutably offsets year\n   */\n\n\n  append({\n    year = 0\n  }, backwards = false) {\n    tuiAssert.assert(Number.isInteger(year));\n\n    if (backwards) {\n      year *= -1;\n    }\n\n    const resultYear = this.year + year;\n    tuiAssert.assert(TuiYear.isValidYear(resultYear));\n    return new TuiYear(resultYear);\n  }\n\n  toString() {\n    return this.formattedYear;\n  }\n\n  toJSON() {\n    return this.formattedYear;\n  }\n\n}\n/**\n * Immutable object consisting of year and month\n */\n\n\nclass TuiMonth extends TuiYear {\n  /**\n   * @param year\n   * @param month (starting with 0)\n   */\n  constructor(year, month) {\n    super(year);\n    this.month = month;\n    tuiAssert.assert(TuiMonth.isValidMonth(year, month));\n  }\n  /**\n   * Tests month and year for validity\n   */\n\n\n  static isValidMonth(year, month) {\n    return TuiYear.isValidYear(year) && TuiMonth.isValidMonthPart(month);\n  }\n  /**\n   * Returns number of days in a month\n   */\n\n\n  static getMonthDaysCount(month, isLeapYear) {\n    tuiAssert.assert(TuiMonth.isValidMonthPart(month));\n\n    switch (month) {\n      case 1\n      /* February */\n      :\n        return isLeapYear ? 29 : 28;\n\n      case 3\n      /* April */\n      :\n      case 5\n      /* June */\n      :\n      case 8\n      /* September */\n      :\n      case 10\n      /* November */\n      :\n        return 30;\n\n      default:\n        return 31;\n    }\n  }\n  /**\n   * Returns current month and year based on local time zone\n   * @nosideeffects\n   */\n\n\n  static currentLocal() {\n    const nativeDate = new Date();\n    return new TuiMonth(nativeDate.getFullYear(), nativeDate.getMonth());\n  }\n  /**\n   * Returns current month and year based on UTC\n   */\n\n\n  static currentUtc() {\n    const nativeDate = new Date();\n    return new TuiMonth(nativeDate.getUTCFullYear(), nativeDate.getUTCMonth());\n  }\n\n  static lengthBetween(from, to) {\n    const absoluteFrom = from.month + from.year * 12;\n    const absoluteTo = to.month + to.year * 12;\n    return absoluteTo - absoluteFrom;\n  }\n  /**\n   * Normalizes number by clamping it between min and max month\n   */\n\n\n  static normalizeMonthPart(month) {\n    return normalizeToIntNumber(month, MIN_MONTH, MAX_MONTH);\n  }\n  /**\n   * Tests month for validity\n   */\n\n\n  static isValidMonthPart(month) {\n    return Number.isInteger(month) && inRange(month, MIN_MONTH, MAX_MONTH + 1);\n  }\n\n  get formattedMonthPart() {\n    return padStart(String(this.month + 1), 2, '0');\n  }\n  /**\n   * @deprecated\n   * TODO remove in 3.0\n   * Formatter month and year\n   */\n\n\n  get formattedMonth() {\n    return `${this.formattedMonthPart}.${this.formattedYear}`;\n  }\n  /**\n   * @deprecated DONT USE IT (will be deleted soon)\n   *\n   * Calculates number of weeks in a month (counting non-full weeks)\n   */\n\n\n  get weeksRowsCount() {\n    return Math.ceil((this.monthStartDaysOffset + this.daysCount) / DAYS_IN_WEEK);\n  }\n  /**\n   * Returns days in a month\n   */\n\n\n  get daysCount() {\n    return TuiMonth.getMonthDaysCount(this.month, this.isLeapYear);\n  }\n  /**\n   * @deprecated DONT USE IT (will be deleted soon)\n   *\n   * Computes day of week offset of the beginning of the month\n   */\n\n\n  get monthStartDaysOffset() {\n    let result = this.yearStartDaysOffset;\n\n    for (let currentMonth = 0; currentMonth <= this.month - 1; currentMonth++) {\n      result += TuiMonth.getMonthDaysCount(currentMonth, this.isLeapYear);\n    }\n\n    return result % DAYS_IN_WEEK;\n  }\n  /**\n   * Passed month and year are after current\n   */\n\n\n  monthBefore(another) {\n    return this.yearBefore(another) || this.yearSame(another) && this.month < another.month;\n  }\n  /**\n   * Passed month and year are after or the same as current\n   */\n\n\n  monthSameOrBefore(another) {\n    return this.yearBefore(another) || this.yearSame(another) && this.month <= another.month;\n  }\n  /**\n   * Passed month and year are the same as current\n   */\n\n\n  monthSame(another) {\n    return this.yearSame(another) && this.month === another.month;\n  }\n  /**\n   * Passed month and year are either before or equal to current\n   */\n\n\n  monthSameOrAfter(another) {\n    return this.yearAfter(another) || this.yearSame(another) && this.month >= another.month;\n  }\n  /**\n   * Passed month and year are before current\n   */\n\n\n  monthAfter(another) {\n    return this.yearAfter(another) || this.yearSame(another) && this.month > another.month;\n  } // TODO: Consider removing `backwards` option\n\n  /**\n   * Immutably alters current month and year by passed offset\n   *\n   * @param offset\n   * @param backwards shift date backwards\n   * @return new month and year object as a result of offsetting current\n   */\n\n\n  append({\n    year = 0,\n    month = 0\n  }, backwards = false) {\n    if (backwards) {\n      year *= -1;\n      month *= -1;\n    }\n\n    const totalMonths = (this.year + year) * MONTHS_IN_YEAR + this.month + month;\n    return new TuiMonth(Math.floor(totalMonths / MONTHS_IN_YEAR), totalMonths % MONTHS_IN_YEAR);\n  }\n\n  toString() {\n    return this.formattedMonth;\n  }\n\n  toJSON() {\n    return `${super.toJSON()}-${this.formattedMonthPart}`;\n  }\n  /**\n   * Returns native {@link Date} based on local time zone\n   */\n\n\n  toLocalNativeDate() {\n    return new Date(this.year, this.month);\n  }\n  /**\n   * Returns native {@link Date} based on UTC\n   */\n\n\n  toUtcNativeDate() {\n    return new Date(Date.UTC(this.year, this.month));\n  }\n\n} // TODO: Localized formatting\n\n/**\n * Immutable date object, consisting of day, month and year\n */\n\n\nclass TuiDay extends TuiMonth {\n  constructor(year, month, day) {\n    super(year, month);\n    this.day = day;\n    tuiAssert.assert(TuiDay.isValidDay(year, month, day));\n  }\n  /**\n   * Creates {@link TuiDay} from native {@link Date} based on local time zone\n   */\n\n\n  static fromLocalNativeDate(date) {\n    return new TuiDay(date.getFullYear(), date.getMonth(), date.getDate());\n  }\n  /**\n   * Creates {@link TuiDay} from native {@link Date} using UTC\n   */\n\n\n  static fromUtcNativeDate(date) {\n    return new TuiDay(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate());\n  }\n  /**\n   * Check validity of year, month and day\n   *\n   * @param year\n   * @param month\n   * @param day\n   * @return boolean validity\n   */\n\n\n  static isValidDay(year, month, day) {\n    return TuiMonth.isValidMonth(year, month) && Number.isInteger(day) && inRange(day, MIN_DAY, TuiMonth.getMonthDaysCount(month, TuiYear.isLeapYear(year)) + 1);\n  }\n  /**\n   * @deprecated DONT USE IT (will be deleted soon)\n   *\n   * Calculated day on a calendar grid\n   *\n   * @param month\n   * @param row row in a calendar\n   * @param col column in a calendar\n   * @return resulting day on these coordinates (could exceed passed month)\n   */\n\n\n  static getDayFromMonthRowCol(month, row, col) {\n    tuiAssert.assert(Number.isInteger(row));\n    tuiAssert.assert(inRange(row, 0, 6));\n    tuiAssert.assert(Number.isInteger(col));\n    tuiAssert.assert(inRange(col, 0, DAYS_IN_WEEK));\n    let day = row * DAYS_IN_WEEK + col - month.monthStartDaysOffset + 1;\n\n    if (day > month.daysCount) {\n      day = day - month.daysCount;\n      month = month.append({\n        month: 1\n      });\n    }\n\n    if (day <= 0) {\n      month = month.append({\n        month: -1\n      });\n      day = month.daysCount + day;\n    }\n\n    return new TuiDay(month.year, month.month, day);\n  }\n  /**\n   * Current day based on local time zone\n   */\n\n\n  static currentLocal() {\n    const nativeDate = new Date();\n    const year = nativeDate.getFullYear();\n    const month = nativeDate.getMonth();\n    const day = nativeDate.getDate();\n    return new TuiDay(year, month, day);\n  }\n  /**\n   * Calculates {@link TuiDay} normalizing year, month and day. {@link NaN} is turned into minimal value.\n   *\n   * @param year any year value, including invalid\n   * @param month any month value, including invalid (months start with 0)\n   * @param day any day value, including invalid\n   * @return normalized date\n   */\n\n\n  static normalizeOf(year, month, day) {\n    const normalizedYear = TuiYear.normalizeYearPart(year);\n    const normalizedMonth = TuiMonth.normalizeMonthPart(month);\n    const normalizedDay = TuiDay.normalizeDayPart(day, normalizedMonth, normalizedYear);\n    return new TuiDay(normalizedYear, normalizedMonth, normalizedDay);\n  }\n\n  static lengthBetween(from, to) {\n    return Math.round((to.toLocalNativeDate().getTime() - from.toLocalNativeDate().getTime()) / (1000 * 60 * 60 * 24));\n  }\n\n  static parseRawDateString(date, dateMode = 'DMY') {\n    tuiAssert.assert(date.length === DATE_FILLER_LENGTH, '[parseRawDateString]: wrong date string length');\n\n    switch (dateMode) {\n      case 'YMD':\n        return {\n          day: parseInt(date.slice(8, 10), 10),\n          month: parseInt(date.slice(5, 7), 10) - 1,\n          year: parseInt(date.slice(0, 4), 10)\n        };\n\n      case 'MDY':\n        return {\n          day: parseInt(date.slice(3, 5), 10),\n          month: parseInt(date.slice(0, 2), 10) - 1,\n          year: parseInt(date.slice(6, 10), 10)\n        };\n\n      default:\n      case 'DMY':\n        return {\n          day: parseInt(date.slice(0, 2), 10),\n          month: parseInt(date.slice(3, 5), 10) - 1,\n          year: parseInt(date.slice(6, 10), 10)\n        };\n    }\n  } // TODO: Move month and year related code corresponding classes\n\n  /**\n   * Parsing a string with date with normalization\n   *\n   * @param rawDate date string\n   * @param dateMode date format of the date string (DMY | MDY | YMD)\n   * @return normalized date\n   */\n\n\n  static normalizeParse(rawDate, dateMode = 'DMY') {\n    const {\n      day,\n      month,\n      year\n    } = this.parseRawDateString(rawDate, dateMode);\n    return TuiDay.normalizeOf(year, month, day);\n  }\n  /**\n   * Parsing a date stringified in a toJSON format\n   * @param yearMonthDayString date string in format of YYYY-MM-DD\n   * @return date\n   * @throws exceptions if any part of the date is invalid\n   */\n\n\n  static jsonParse(yearMonthDayString) {\n    const {\n      day,\n      month,\n      year\n    } = this.parseRawDateString(yearMonthDayString, 'YMD');\n\n    if (!TuiYear.isValidYear(year)) {\n      throw new InvalidYearException(year);\n    }\n\n    if (!TuiMonth.isValidMonth(year, month)) {\n      throw new InvalidMonthException(month);\n    }\n\n    if (!Number.isInteger(day) || !inRange(day, MIN_DAY, TuiMonth.getMonthDaysCount(month, TuiYear.isLeapYear(year)) + 1)) {\n      throw new InvalidDayException(day);\n    }\n\n    return new TuiDay(year, month, day);\n  }\n\n  static normalizeDayPart(day, month, year) {\n    tuiAssert.assert(TuiMonth.isValidMonth(year, month));\n    const monthDaysCount = TuiMonth.getMonthDaysCount(month, TuiYear.isLeapYear(year));\n    return normalizeToIntNumber(day, 1, monthDaysCount);\n  }\n\n  get formattedDayPart() {\n    return padStart(String(this.day), 2, '0');\n  }\n  /**\n   * @deprecated use {@link getFormattedDay} instead\n   * TODO remove in 3.0\n   * Formatted whole date\n   */\n\n\n  get formattedDay() {\n    return `${this.formattedDayPart}.${this.formattedMonth}`;\n  }\n\n  get isWeekend() {\n    const dayOfWeek = this.dayOfWeek(false);\n    return dayOfWeek === 6\n    /* Saturday */\n    || dayOfWeek === 0\n    /* Sunday */\n    ;\n  }\n  /**\n   * Returns day of week\n   *\n   * @param startFromMonday whether week starts from Monday and not from Sunday\n   * @return day of week (from 0 to 6)\n   */\n\n\n  dayOfWeek(startFromMonday = true) {\n    const dayOfWeek = startFromMonday ? this.toLocalNativeDate().getDay() - 1 : this.toLocalNativeDate().getDay();\n    return dayOfWeek < 0 ? 6 : dayOfWeek;\n  }\n  /**\n   * Passed date is after current\n   */\n\n\n  dayBefore(another) {\n    return this.monthBefore(another) || this.monthSame(another) && this.day < another.day;\n  }\n  /**\n   * Passed date is after or equals to current\n   */\n\n\n  daySameOrBefore(another) {\n    return this.monthBefore(another) || this.monthSame(another) && this.day <= another.day;\n  }\n  /**\n   * Passed date is the same as current\n   */\n\n\n  daySame(another) {\n    return this.monthSame(another) && this.day === another.day;\n  }\n  /**\n   * Passed date is either before or the same as current\n   */\n\n\n  daySameOrAfter(another) {\n    return this.monthAfter(another) || this.monthSame(another) && this.day >= another.day;\n  }\n  /**\n   * Passed date is before current\n   */\n\n\n  dayAfter(another) {\n    return this.monthAfter(another) || this.monthSame(another) && this.day > another.day;\n  }\n  /**\n   * Clamping date between two limits\n   *\n   * @param min\n   * @param max\n   * @return clamped date\n   */\n\n\n  dayLimit(min, max) {\n    if (min !== null && this.dayBefore(min)) {\n      return min;\n    }\n\n    if (max !== null && this.dayAfter(max)) {\n      return max;\n    }\n\n    return this;\n  } // TODO: Consider removing `backwards` option\n\n  /**\n   * Immutably alters current day by passed offset\n   *\n   * If resulting month has more days than original one, date is rounded to the maximum day\n   * in the resulting month. Offset of days will be calculated based on the resulted year and month\n   * to not interfere with parent classes methods\n   *\n   * @param offset\n   * @param backwards shift date backwards\n   * @return new date object as a result of offsetting current\n   */\n\n\n  append({\n    year = 0,\n    month = 0,\n    day = 0\n  }, backwards = false) {\n    if (backwards) {\n      year *= -1;\n      month *= -1;\n      day *= -1;\n    }\n\n    const totalMonths = (this.year + year) * MONTHS_IN_YEAR + this.month + month;\n    let years = Math.floor(totalMonths / MONTHS_IN_YEAR);\n    let months = totalMonths % MONTHS_IN_YEAR;\n    let days = Math.min(this.day, TuiMonth.getMonthDaysCount(months, TuiYear.isLeapYear(years))) + day;\n\n    while (days > TuiMonth.getMonthDaysCount(months, TuiYear.isLeapYear(years))) {\n      days -= TuiMonth.getMonthDaysCount(months, TuiYear.isLeapYear(years));\n\n      if (months === 11\n      /* December */\n      ) {\n        years++;\n        months = 0\n        /* January */\n        ;\n      } else {\n        months++;\n      }\n    }\n\n    while (days < MIN_DAY) {\n      if (months === 0\n      /* January */\n      ) {\n        years--;\n        months = 11\n        /* December */\n        ;\n      } else {\n        months--;\n      }\n\n      days += TuiMonth.getMonthDaysCount(months, TuiYear.isLeapYear(years));\n    }\n\n    return new TuiDay(years, months, days);\n  }\n  /**\n   * Returns formatted whole date\n   */\n\n\n  getFormattedDay(dateFormat, separator) {\n    tuiAssert.assert(separator.length === 1, 'Separator should consist of only 1 symbol');\n    const dd = this.formattedDayPart;\n    const mm = this.formattedMonthPart;\n    const yyyy = this.formattedYear;\n\n    switch (dateFormat) {\n      case 'YMD':\n        return `${yyyy}${separator}${mm}${separator}${dd}`;\n\n      case 'MDY':\n        return `${mm}${separator}${dd}${separator}${yyyy}`;\n\n      case 'DMY':\n      default:\n        return `${dd}${separator}${mm}${separator}${yyyy}`;\n    }\n  }\n\n  toString(dateFormat = 'DMY', separator = '.') {\n    return this.getFormattedDay(dateFormat, separator);\n  }\n\n  toJSON() {\n    return `${super.toJSON()}-${this.formattedDayPart}`;\n  }\n  /**\n   * Returns native {@link Date} based on local time zone\n   */\n\n\n  toLocalNativeDate() {\n    return new Date(this.year, this.month, this.day);\n  }\n  /**\n   * Returns native {@link Date} based on UTC\n   */\n\n\n  toUtcNativeDate() {\n    return new Date(Date.UTC(this.year, this.month, this.day));\n  }\n\n}\n/**\n * An immutable range of two {@link TuiMonth} objects\n */\n\n\nclass TuiMonthRange {\n  constructor(from, to) {\n    this.from = from;\n    this.to = to;\n    tuiAssert.assert(from.monthSameOrBefore(to));\n  }\n\n  static sort(month1, month2) {\n    return month1.monthSameOrBefore(month2) ? new TuiMonthRange(month1, month2) : new TuiMonthRange(month2, month1);\n  }\n\n  get isSingleMonth() {\n    return this.from.monthSame(this.to);\n  }\n  /**\n   * @deprecated\n   * TODO remove in 3.0\n   */\n\n\n  get formattedMonthRange() {\n    return `${this.from.formattedMonth}${RANGE_SEPARATOR_CHAR}${this.to.formattedMonth}`;\n  }\n\n  monthSame(another) {\n    return this.from.monthSame(another.from) && this.to.monthSame(another.to);\n  }\n\n  toString() {\n    return `${this.from}${RANGE_SEPARATOR_CHAR}${this.to}`;\n  }\n\n}\n/**\n * Temporary type guard to satisfy ts-overloading of normalizeParse method\n * @deprecated TODO rm in v3.0\n */\n\n\nconst isDateMode = dateMode => ['DMY', 'YMD', 'MDY'].includes(dateMode);\n/**\n * An immutable range of two {@link TuiDay} objects\n */\n\n\nclass TuiDayRange extends TuiMonthRange {\n  constructor(from, to) {\n    super(from, to);\n    this.from = from;\n    this.to = to;\n    tuiAssert.assert(from.daySameOrBefore(to));\n  }\n  /**\n   * Creates range from two days after sorting them\n   *\n   * @param day1\n   * @param day2\n   * @return new range with sorted days\n   */\n\n\n  static sort(day1, day2) {\n    return day1.daySameOrBefore(day2) ? new TuiDayRange(day1, day2) : new TuiDayRange(day2, day1);\n  }\n  /**\n   * Parse and correct a day range in string format\n   *\n   * @param rangeString a string of dates in a format dd.mm.yyyy - dd.mm.yyyy\n   * @param dateMode {@link TuiDateMode}\n   * @return normalized day range object\n   */\n\n\n  static normalizeParse(rangeString, dateMode = 'DMY') {\n    const dateFormat = isDateMode(dateMode) ? dateMode : 'DMY';\n    const leftDay = TuiDay.normalizeParse(rangeString.slice(0, DATE_FILLER_LENGTH), dateFormat);\n\n    if (rangeString.length < DATE_RANGE_FILLER_LENGTH) {\n      return new TuiDayRange(leftDay, leftDay);\n    }\n\n    return TuiDayRange.sort(leftDay, TuiDay.normalizeParse(rangeString.slice(DATE_FILLER_LENGTH + RANGE_SEPARATOR_CHAR.length), dateFormat));\n  }\n\n  get isSingleDay() {\n    return this.from.daySame(this.to);\n  }\n  /**\n   * Human readable format.\n   * @deprecated use {@link getFormattedDayRange} instead\n   */\n\n\n  get formattedDayRange() {\n    const from = this.from.getFormattedDay('DMY', '.');\n    const to = this.to.getFormattedDay('DMY', '.');\n    return `${from}${RANGE_SEPARATOR_CHAR}${to}`;\n  }\n  /**\n   * Tests ranges for identity\n   *\n   * @param another second range to test against current\n   * @return `true` if days are identical\n   */\n\n\n  daySame(another) {\n    return this.from.daySame(another.from) && this.to.daySame(another.to);\n  }\n  /**\n   * Locks range between two days included, or limits from one side if the other is null\n   *\n   * @param min\n   * @param max\n   * @return range — clamped range\n   */\n\n\n  dayLimit(min, max) {\n    return new TuiDayRange(this.from.dayLimit(min, max), this.to.dayLimit(min, max));\n  }\n  /**\n   * Human readable format.\n   */\n\n\n  getFormattedDayRange(dateFormat, dateSeparator) {\n    const from = this.from.getFormattedDay(dateFormat, dateSeparator);\n    const to = this.to.getFormattedDay(dateFormat, dateSeparator);\n    return `${from}${RANGE_SEPARATOR_CHAR}${to}`;\n  }\n\n  toString(dateFormat = 'DMY', dateSeparator = '.') {\n    const from = this.from.getFormattedDay(dateFormat, dateSeparator);\n    const to = this.to.getFormattedDay(dateFormat, dateSeparator);\n    return `${from}${RANGE_SEPARATOR_CHAR}${to}`;\n  }\n\n}\n\nconst TUI_FIRST_DAY = new TuiDay(MIN_YEAR, MIN_MONTH, MIN_DAY);\nconst TUI_LAST_DAY = new TuiDay(MAX_YEAR, MAX_MONTH, 31);\n/**\n * Immutable time object with hours, minutes, seconds and ms\n */\n\nclass TuiTime {\n  constructor(hours, minutes, seconds = 0, ms = 0) {\n    this.hours = hours;\n    this.minutes = minutes;\n    this.seconds = seconds;\n    this.ms = ms;\n    tuiAssert.assert(TuiTime.isValidTime(hours, minutes, seconds, ms), 'Time must be real, but got:', hours, minutes, seconds, ms);\n  }\n  /**\n   * Checks if time is valid\n   */\n\n\n  static isValidTime(hours, minutes, seconds = 0, ms = 0) {\n    return Number.isInteger(hours) && inRange(hours, 0, HOURS_IN_DAY) && Number.isInteger(minutes) && inRange(minutes, 0, MINUTES_IN_HOUR) && Number.isInteger(seconds) && inRange(seconds, 0, SECONDS_IN_MINUTE) && Number.isInteger(ms) && inRange(ms, 0, 1000);\n  }\n  /**\n   * Current UTC time.\n   */\n\n\n  static current() {\n    return TuiTime.fromAbsoluteMilliseconds(Date.now() % MILLISECONDS_IN_DAY);\n  }\n  /**\n   * Current time in local timezone\n   */\n\n\n  static currentLocal() {\n    const date = new Date();\n    return TuiTime.fromAbsoluteMilliseconds((Date.now() - date.getTimezoneOffset() * MILLISECONDS_IN_MINUTE) % MILLISECONDS_IN_DAY);\n  }\n  /**\n   * Calculates TuiTime from milliseconds\n   */\n\n\n  static fromAbsoluteMilliseconds(milliseconds) {\n    tuiAssert.assert(Number.isInteger(milliseconds));\n    tuiAssert.assert(inRange(milliseconds, 0, MILLISECONDS_IN_DAY), `Milliseconds must be below ${MILLISECONDS_IN_DAY} (milliseconds in a day).`);\n    const hours = Math.floor(milliseconds / MILLISECONDS_IN_HOUR);\n    const minutes = Math.floor(milliseconds % MILLISECONDS_IN_HOUR / MILLISECONDS_IN_MINUTE);\n    const seconds = Math.floor(milliseconds % MILLISECONDS_IN_HOUR % MILLISECONDS_IN_MINUTE / 1000) || 0;\n    const ms = Math.floor(milliseconds % MILLISECONDS_IN_HOUR % MILLISECONDS_IN_MINUTE % 1000) || 0;\n    return new TuiTime(hours, minutes, seconds, ms);\n  }\n  /**\n   * Parses string into TuiTime object\n   */\n\n\n  static fromString(time) {\n    const hours = Number(time.slice(0, 2));\n    const minutes = Number(time.slice(3, 5));\n    const seconds = Number(time.slice(6, 8)) || 0;\n    const ms = Number(time.slice(9, 12)) || 0;\n    return new TuiTime(hours, minutes, seconds, ms);\n  }\n  /**\n   * Converts Date object into TuiTime\n   * @param date\n   */\n\n\n  static fromLocalNativeDate(date) {\n    return new TuiTime(date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds());\n  }\n  /**\n   * Shifts time by hours and minutes\n   */\n\n\n  shift({\n    hours = 0,\n    minutes = 0,\n    seconds = 0,\n    ms = 0\n  }) {\n    const newMs = (1000 + this.ms + ms % 1000) % 1000;\n    const secondsInMs = ms < 0 ? Math.ceil(ms / 1000) : Math.floor(ms / 1000);\n    const secondsToAdd = secondsInMs + seconds;\n    const newSeconds = (60 + this.seconds + secondsToAdd % 60) % 60;\n    const minutesInSeconds = secondsToAdd < 0 ? Math.ceil(secondsToAdd / 60) : Math.floor(secondsToAdd / 60);\n    const minutesToAdd = minutesInSeconds + minutes;\n    const newMinutes = (60 + this.minutes + minutesToAdd % 60) % 60;\n    const hoursInMinutes = minutesToAdd < 0 ? Math.ceil(minutesToAdd / 60) : Math.floor(minutesToAdd / 60);\n    const hoursToAdd = hoursInMinutes + hours;\n    const newHours = (24 + this.hours + hoursToAdd % 24) % 24;\n    return new TuiTime(newHours, newMinutes, newSeconds, newMs);\n  }\n  /**\n   * Converts TuiTime to string\n   */\n\n\n  toString(mode) {\n    const needAddMs = mode === 'HH:MM:SS.MSS' || !mode && this.ms > 0;\n    const needAddSeconds = needAddMs || mode === 'HH:MM:SS' || !mode && this.seconds > 0;\n    return `${this.formatTime(this.hours)}:${this.formatTime(this.minutes)}` + `${needAddSeconds ? `:${this.formatTime(this.seconds)}` : ''}` + `${needAddMs ? `.${this.formatTime(this.ms, 3)}` : ''}`;\n  }\n  /**\n   * Converts TuiTime to milliseconds\n   */\n\n\n  toAbsoluteMilliseconds() {\n    return this.hours * MILLISECONDS_IN_HOUR + this.minutes * MILLISECONDS_IN_MINUTE + this.seconds * 1000 + this.ms;\n  }\n\n  formatTime(time, digits = 2) {\n    return padStart(String(time), digits, '0');\n  }\n\n}\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { DATE_FILLER_LENGTH, DATE_RANGE_FILLER_LENGTH, DAYS_IN_LEAP_YEAR, DAYS_IN_NORMAL_YEAR, DAYS_IN_WEEK, HOURS_IN_DAY, MAX_MONTH, MAX_YEAR, MILLISECONDS_IN_DAY, MILLISECONDS_IN_HOUR, MILLISECONDS_IN_MINUTE, MILLISECONDS_IN_SECOND, MINUTES_IN_HOUR, MIN_DAY, MIN_MONTH, MIN_YEAR, MONTHS_IN_YEAR, RANGE_SEPARATOR_CHAR, SECONDS_IN_MINUTE, TUI_DATE_FILLER, TUI_DATE_FORMAT, TUI_DATE_RANGE_FILLER, TUI_DATE_SEPARATOR, TUI_FIRST_DAY, TUI_LAST_DAY, TuiDay, TuiDayRange, TuiMonth, TuiMonthRange, TuiTime, TuiYear, changeDateSeparator, isDateMode }; //# sourceMappingURL=taiga-ui-cdk-date-time.js.map","map":null,"metadata":{},"sourceType":"module"}