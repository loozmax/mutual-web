{"ast":null,"code":"import { __decorate, __param } from 'tslib';\nimport { Injectable, ComponentFactoryResolver, Inject, Injector, INJECTOR, Renderer2, ɵɵdefineInjectable, ɵɵinject, ElementRef, ChangeDetectorRef, NgZone, Self } from '@angular/core';\nimport { ReplaySubject, Observable, merge, defer, fromEvent, of, timer } from 'rxjs';\nimport { DOCUMENT } from '@angular/common';\nimport { TUI_DEFAULT_RENDERER, TUI_SWIPE_OPTIONS, TUI_ZOOM_OPTIONS } from '@taiga-ui/cdk/tokens';\nimport { focusVisibleObservable, watch, typedFromEvent, tuiZoneOptimized, tuiZonefree, preventDefault } from '@taiga-ui/cdk/observables';\nimport { takeUntil, switchMap, filter, take, mapTo, startWith, distinctUntilChanged, delay, throttleTime, map, switchMapTo, pairwise, repeat, catchError, debounceTime, tap, shareReplay, scan } from 'rxjs/operators';\nimport { getActualTarget, getElementObscurers } from '@taiga-ui/cdk/utils/dom';\nimport { WINDOW, ANIMATION_FRAME, PERFORMANCE } from '@ng-web-apis/common';\nimport { POLLING_TIME, EMPTY_ARRAY } from '@taiga-ui/cdk/constants';\nimport { ResizeObserverService, RESIZE_OBSERVER_SUPPORT, RESIZE_OPTION_BOX } from '@ng-web-apis/resize-observer';\nimport { tuiAssert } from '@taiga-ui/cdk/classes';\nimport { clamp } from '@taiga-ui/cdk/utils/math';\nimport { easeInOutQuad, getSwipeDirection, isPresent } from '@taiga-ui/cdk/utils/miscellaneous';\nimport { distanceBetweenTouches } from '@taiga-ui/cdk/utils';\n/**\n * Observable abstraction over ngOnDestroy to use with takeUntil\n */\n\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from 'rxjs';\nlet TuiDestroyService = /*#__PURE__*/(() => {\n  let TuiDestroyService = class TuiDestroyService extends ReplaySubject {\n    constructor() {\n      super(1);\n    }\n\n    ngOnDestroy() {\n      this.next();\n      this.complete();\n    }\n\n  };\n\n  TuiDestroyService.ɵfac = function TuiDestroyService_Factory(t) {\n    return new (t || TuiDestroyService)();\n  };\n\n  TuiDestroyService.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: TuiDestroyService,\n    factory: function (t) {\n      return TuiDestroyService.ɵfac(t);\n    }\n  });\n  /**\n   * Service to use styles with directives\n   * @dynamic\n   */\n\n  return TuiDestroyService;\n})();\nlet TuiDirectiveStylesService = /*#__PURE__*/(() => {\n  let TuiDirectiveStylesService = class TuiDirectiveStylesService {\n    constructor(resolver, injector, documentRef, renderer) {\n      this.resolver = resolver;\n      this.injector = injector;\n      this.documentRef = documentRef;\n      this.renderer = renderer;\n      this.map = new Map();\n    }\n\n    addComponent(component) {\n      if (!this.map.has(component)) {\n        this.map.set(component, this.resolver.resolveComponentFactory(component).create(this.injector));\n      }\n    }\n    /** @deprecated use components approach */\n\n\n    addStyle(styles, attribute) {\n      if (this.documentRef.head.querySelector(`style[${attribute}]`)) {\n        return;\n      }\n\n      const style = this.renderer.createElement('style');\n      this.renderer.setProperty(style, 'textContent', styles);\n      this.renderer.setAttribute(style, attribute, '');\n      this.documentRef.head.appendChild(style);\n    }\n\n  };\n\n  TuiDirectiveStylesService.ɵfac = function TuiDirectiveStylesService_Factory(t) {\n    return new (t || TuiDirectiveStylesService)(ɵngcc0.ɵɵinject(ComponentFactoryResolver), ɵngcc0.ɵɵinject(INJECTOR), ɵngcc0.ɵɵinject(DOCUMENT), ɵngcc0.ɵɵinject(TUI_DEFAULT_RENDERER));\n  };\n\n  TuiDirectiveStylesService.ɵprov = ɵɵdefineInjectable({\n    factory: function TuiDirectiveStylesService_Factory() {\n      return new TuiDirectiveStylesService(ɵɵinject(ComponentFactoryResolver), ɵɵinject(INJECTOR), ɵɵinject(DOCUMENT), ɵɵinject(TUI_DEFAULT_RENDERER));\n    },\n    token: TuiDirectiveStylesService,\n    providedIn: \"root\"\n  });\n  TuiDirectiveStylesService = __decorate([__param(0, Inject(ComponentFactoryResolver)), __param(1, Inject(INJECTOR)), __param(2, Inject(DOCUMENT)), __param(3, Inject(TUI_DEFAULT_RENDERER))], TuiDirectiveStylesService);\n  /**\n   * Service to imitate :focus-visible\n   * (https://developer.mozilla.org/en-US/docs/Web/CSS/:focus-visible)\n   * in browsers that do not support it\n   * @dynamic\n   */\n\n  return TuiDirectiveStylesService;\n})();\nlet TuiFocusVisibleService = /*#__PURE__*/(() => {\n  let TuiFocusVisibleService = class TuiFocusVisibleService extends Observable {\n    constructor({\n      nativeElement\n    }, changeDetectorRef, destroy$) {\n      super(subscriber => this.focusVisible$.subscribe(subscriber));\n      this.focusVisible$ = focusVisibleObservable(nativeElement).pipe(watch(changeDetectorRef), takeUntil(destroy$));\n    }\n\n  };\n\n  TuiFocusVisibleService.ɵfac = function TuiFocusVisibleService_Factory(t) {\n    return new (t || TuiFocusVisibleService)(ɵngcc0.ɵɵinject(ElementRef), ɵngcc0.ɵɵinject(ChangeDetectorRef), ɵngcc0.ɵɵinject(TuiDestroyService));\n  };\n\n  TuiFocusVisibleService.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: TuiFocusVisibleService,\n    factory: function (t) {\n      return TuiFocusVisibleService.ɵfac(t);\n    }\n  });\n  TuiFocusVisibleService = __decorate([__param(0, Inject(ElementRef)), __param(1, Inject(ChangeDetectorRef)), __param(2, Inject(TuiDestroyService))], TuiFocusVisibleService); // @dynamic\n\n  return TuiFocusVisibleService;\n})();\nlet TuiHoveredService = /*#__PURE__*/(() => {\n  let TuiHoveredService = class TuiHoveredService {\n    constructor(documentRef, ngZone) {\n      this.ngZone = ngZone;\n      this.documentEvents$ = merge(typedFromEvent(documentRef, 'mousemove'), typedFromEvent(documentRef, 'touchstart', {\n        capture: true\n      }));\n    }\n\n    createHovered$(target, options = {\n      passive: true\n    }) {\n      return merge(typedFromEvent(target, 'mouseenter', options), typedFromEvent(target, 'touchstart', options)).pipe(switchMap(() => merge(typedFromEvent(target, 'mouseleave', options), this.documentEvents$.pipe(filter(event => !target.contains(getActualTarget(event))), tuiZoneOptimized(this.ngZone), take(1))).pipe(mapTo(false), startWith(true))), distinctUntilChanged());\n    }\n\n  };\n\n  TuiHoveredService.ɵfac = function TuiHoveredService_Factory(t) {\n    return new (t || TuiHoveredService)(ɵngcc0.ɵɵinject(DOCUMENT), ɵngcc0.ɵɵinject(NgZone));\n  };\n\n  TuiHoveredService.ɵprov = ɵɵdefineInjectable({\n    factory: function TuiHoveredService_Factory() {\n      return new TuiHoveredService(ɵɵinject(DOCUMENT), ɵɵinject(NgZone));\n    },\n    token: TuiHoveredService,\n    providedIn: \"root\"\n  });\n  TuiHoveredService = __decorate([__param(0, Inject(DOCUMENT)), __param(1, Inject(NgZone))], TuiHoveredService);\n  return TuiHoveredService;\n})();\nvar TuiIdService_1;\nconst TUI = 'tui_';\n/**\n * Generates unique ids\n */\n\nlet TuiIdService = TuiIdService_1 = class TuiIdService {\n  generate() {\n    return `${TUI}${TuiIdService_1.autoId++}${Date.now()}`;\n  }\n\n};\n\nTuiIdService.ɵfac = function TuiIdService_Factory(t) {\n  return new (t || TuiIdService)();\n};\n\nTuiIdService.autoId = 0;\nTuiIdService.ɵprov = ɵɵdefineInjectable({\n  factory: function TuiIdService_Factory() {\n    return new TuiIdService();\n  },\n  token: TuiIdService,\n  providedIn: \"root\"\n});\n/**\n * Service that subscribes to scroll events of all parent elements\n */\n// Ambient type cannot be used without dynamic https://github.com/angular/angular/issues/23395\n// @dynamic\n\nlet TuiParentsScrollService = /*#__PURE__*/(() => {\n  let TuiParentsScrollService = class TuiParentsScrollService extends Observable {\n    constructor(elementRef, windowRef) {\n      super(subscriber => this.callback$.subscribe(subscriber));\n      this.callback$ = defer(() => {\n        let {\n          nativeElement\n        } = elementRef;\n        const eventTargets = [windowRef, nativeElement];\n\n        while (nativeElement.parentElement) {\n          nativeElement = nativeElement.parentElement;\n          eventTargets.push(nativeElement);\n        }\n\n        return merge(...eventTargets.map(element => typedFromEvent(element, 'scroll')));\n      });\n    }\n\n  };\n\n  TuiParentsScrollService.ɵfac = function TuiParentsScrollService_Factory(t) {\n    return new (t || TuiParentsScrollService)(ɵngcc0.ɵɵinject(ElementRef), ɵngcc0.ɵɵinject(WINDOW));\n  };\n\n  TuiParentsScrollService.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: TuiParentsScrollService,\n    factory: function (t) {\n      return TuiParentsScrollService.ɵfac(t);\n    }\n  });\n  TuiParentsScrollService = __decorate([__param(0, Inject(ElementRef)), __param(1, Inject(WINDOW))], TuiParentsScrollService); // @bad TODO: Consider Intersection Observer with fallback to current implementation\n\n  /**\n   * Service that monitors element visibility by subscribing to scrolls\n   * and polling with set interval, returns either null or an array\n   * of elements that overlap given element edges\n   */\n  // Ambient type cannot be used without dynamic https://github.com/angular/angular/issues/23395\n  // @dynamic\n\n  return TuiParentsScrollService;\n})();\nlet TuiObscuredService = /*#__PURE__*/(() => {\n  let TuiObscuredService = class TuiObscuredService extends Observable {\n    constructor(parentsScroll$, {\n      nativeElement\n    }, ngZone, windowRef, destroy$, animationFrame$) {\n      super(subscriber => this.obscured$.subscribe(subscriber));\n      this.obscured$ = merge( // delay is added so it will not interfere with other listeners\n      merge(parentsScroll$, fromEvent(windowRef, 'resize')).pipe(delay(0)), animationFrame$.pipe(throttleTime(POLLING_TIME))).pipe(map(() => getElementObscurers(nativeElement)), startWith(null), distinctUntilChanged(), tuiZoneOptimized(ngZone), takeUntil(destroy$));\n    }\n\n  };\n\n  TuiObscuredService.ɵfac = function TuiObscuredService_Factory(t) {\n    return new (t || TuiObscuredService)(ɵngcc0.ɵɵinject(TuiParentsScrollService, 2), ɵngcc0.ɵɵinject(ElementRef), ɵngcc0.ɵɵinject(NgZone), ɵngcc0.ɵɵinject(WINDOW), ɵngcc0.ɵɵinject(TuiDestroyService), ɵngcc0.ɵɵinject(ANIMATION_FRAME));\n  };\n\n  TuiObscuredService.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: TuiObscuredService,\n    factory: function (t) {\n      return TuiObscuredService.ɵfac(t);\n    }\n  });\n  TuiObscuredService = __decorate([__param(0, Inject(TuiParentsScrollService)), __param(0, Self()), __param(1, Inject(ElementRef)), __param(2, Inject(NgZone)), __param(3, Inject(WINDOW)), __param(4, Inject(TuiDestroyService)), __param(5, Inject(ANIMATION_FRAME))], TuiObscuredService);\n  /**\n   * @dynamic\n   */\n\n  return TuiObscuredService;\n})();\nlet TuiPanService = /*#__PURE__*/(() => {\n  let TuiPanService = class TuiPanService extends Observable {\n    constructor({\n      nativeElement\n    }, documentRef) {\n      super(subscriber => {\n        merge(typedFromEvent(nativeElement, 'touchstart', {\n          passive: true\n        }), typedFromEvent(nativeElement, 'mousedown')).pipe(switchMapTo(merge(typedFromEvent(documentRef, 'touchmove', {\n          passive: true\n        }).pipe(filter(({\n          touches\n        }) => touches.length < 2), map(({\n          touches\n        }) => touches[0])), typedFromEvent(documentRef, 'mousemove'))), pairwise(), map(([first, second]) => {\n          const deltaX = second.clientX - first.clientX;\n          const deltaY = second.clientY - first.clientY;\n          return [deltaX, deltaY];\n        }), takeUntil(merge(typedFromEvent(documentRef, 'touchend'), typedFromEvent(documentRef, 'mouseup'))), repeat()).subscribe(subscriber);\n      });\n    }\n\n  };\n\n  TuiPanService.ɵfac = function TuiPanService_Factory(t) {\n    return new (t || TuiPanService)(ɵngcc0.ɵɵinject(ElementRef), ɵngcc0.ɵɵinject(DOCUMENT));\n  };\n\n  TuiPanService.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: TuiPanService,\n    factory: function (t) {\n      return TuiPanService.ɵfac(t);\n    }\n  });\n  TuiPanService = __decorate([__param(0, Inject(ElementRef)), __param(1, Inject(DOCUMENT))], TuiPanService); // @dynamic\n\n  return TuiPanService;\n})();\nlet TuiResizeService = /*#__PURE__*/(() => {\n  let TuiResizeService = class TuiResizeService extends ResizeObserverService {\n    constructor(elementRef, ngZone, destroy$, support, box, animationFrame$) {\n      super(elementRef, ngZone, support, box);\n      return this.pipe(catchError(() => animationFrame$.pipe(throttleTime(POLLING_TIME), map(() => `${elementRef.nativeElement.clientWidth} ${elementRef.nativeElement.clientHeight}`), distinctUntilChanged(), mapTo(EMPTY_ARRAY))), takeUntil(destroy$), debounceTime(0), tuiZonefree(ngZone));\n    }\n\n  };\n\n  TuiResizeService.ɵfac = function TuiResizeService_Factory(t) {\n    return new (t || TuiResizeService)(ɵngcc0.ɵɵinject(ElementRef), ɵngcc0.ɵɵinject(NgZone), ɵngcc0.ɵɵinject(TuiDestroyService), ɵngcc0.ɵɵinject(RESIZE_OBSERVER_SUPPORT), ɵngcc0.ɵɵinject(RESIZE_OPTION_BOX), ɵngcc0.ɵɵinject(ANIMATION_FRAME));\n  };\n\n  TuiResizeService.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: TuiResizeService,\n    factory: function (t) {\n      return TuiResizeService.ɵfac(t);\n    }\n  });\n  TuiResizeService = __decorate([__param(0, Inject(ElementRef)), __param(1, Inject(NgZone)), __param(2, Inject(TuiDestroyService)), __param(3, Inject(RESIZE_OBSERVER_SUPPORT)), __param(4, Inject(RESIZE_OPTION_BOX)), __param(5, Inject(ANIMATION_FRAME))], TuiResizeService);\n  return TuiResizeService;\n})();\nconst SCROLL_TIME = 300; // @dynamic\n\nlet TuiScrollService = /*#__PURE__*/(() => {\n  let TuiScrollService = class TuiScrollService {\n    constructor(performanceRef, animationFrame$) {\n      this.performanceRef = performanceRef;\n      this.animationFrame$ = animationFrame$;\n    }\n\n    scroll$(element, scrollTop, scrollLeft = element.scrollLeft, duration = SCROLL_TIME) {\n      tuiAssert.assert(duration >= 0, 'Duration cannot be negative');\n      tuiAssert.assert(scrollTop >= 0, 'scrollTop cannot be negative');\n      tuiAssert.assert(scrollLeft >= 0, 'scrollLeft cannot be negative');\n      const initialTop = element.scrollTop;\n      const initialLeft = element.scrollLeft;\n      const deltaTop = scrollTop - initialTop;\n      const deltaLeft = scrollLeft - initialLeft;\n      const observable = !duration ? of([scrollTop, scrollLeft]) : defer(() => of(this.performanceRef.now())).pipe(switchMap(start => this.animationFrame$.pipe(map(now => now - start))), takeUntil(timer(duration)), map(elapsed => easeInOutQuad(clamp(elapsed / duration, 0, 1))), map(percent => [initialTop + deltaTop * percent, initialLeft + deltaLeft * percent]));\n      return observable.pipe(tap(([scrollTop, scrollLeft]) => {\n        element.scrollTop = scrollTop;\n        element.scrollLeft = scrollLeft;\n      }));\n    }\n\n  };\n\n  TuiScrollService.ɵfac = function TuiScrollService_Factory(t) {\n    return new (t || TuiScrollService)(ɵngcc0.ɵɵinject(PERFORMANCE), ɵngcc0.ɵɵinject(ANIMATION_FRAME));\n  };\n\n  TuiScrollService.ɵprov = ɵɵdefineInjectable({\n    factory: function TuiScrollService_Factory() {\n      return new TuiScrollService(ɵɵinject(PERFORMANCE), ɵɵinject(ANIMATION_FRAME));\n    },\n    token: TuiScrollService,\n    providedIn: \"root\"\n  });\n  TuiScrollService = __decorate([__param(0, Inject(PERFORMANCE)), __param(1, Inject(ANIMATION_FRAME))], TuiScrollService);\n  return TuiScrollService;\n})();\nlet TuiStaticRequestService = /*#__PURE__*/(() => {\n  let TuiStaticRequestService = class TuiStaticRequestService {\n    constructor() {\n      this.cache = new Map();\n    }\n\n    request(url) {\n      const cache = this.cache.get(url);\n\n      if (cache) {\n        return cache;\n      }\n\n      const observable = new Observable(observer => {\n        const xhr = new XMLHttpRequest();\n\n        xhr.onreadystatechange = () => {\n          if (xhr.readyState === 4) {\n            const response = xhr.responseType ? xhr.response : xhr.responseText;\n\n            if (xhr.status === 200) {\n              observer.next(response);\n              observer.complete();\n            } else {\n              observer.error(response);\n            }\n          }\n        };\n\n        xhr.open('GET', url);\n        xhr.send();\n        return () => {\n          xhr.abort();\n        };\n      });\n      const piped = observable.pipe(shareReplay(1));\n      this.cache.set(url, piped);\n      return piped;\n    }\n\n  };\n\n  TuiStaticRequestService.ɵfac = function TuiStaticRequestService_Factory(t) {\n    return new (t || TuiStaticRequestService)();\n  };\n\n  TuiStaticRequestService.ɵprov = ɵɵdefineInjectable({\n    factory: function TuiStaticRequestService_Factory() {\n      return new TuiStaticRequestService();\n    },\n    token: TuiStaticRequestService,\n    providedIn: \"root\"\n  });\n  /**\n   * @dynamic\n   */\n\n  return TuiStaticRequestService;\n})();\nlet TuiSwipeService = /*#__PURE__*/(() => {\n  let TuiSwipeService = class TuiSwipeService extends Observable {\n    constructor({\n      nativeElement\n    }, {\n      timeout,\n      threshold\n    }, documentRef) {\n      super(subscriber => {\n        merge(typedFromEvent(nativeElement, 'touchstart', {\n          passive: true\n        }), typedFromEvent(documentRef, 'touchend')).pipe(pairwise(), filter(([first, second]) => !!first.touches.length && first.touches[0].identifier === second.changedTouches[0].identifier), map(([start, end]) => {\n          const startX = start.touches[0].clientX;\n          const startY = start.touches[0].clientY;\n          const endX = end.changedTouches[0].clientX;\n          const endY = end.changedTouches[0].clientY;\n          const distanceX = startX - endX;\n          const distanceY = startY - endY;\n          const duration = end.timeStamp - start.timeStamp;\n\n          if ((Math.abs(distanceX) > threshold || Math.abs(distanceY) > threshold) && duration < timeout) {\n            return {\n              direction: getSwipeDirection(distanceX, distanceY),\n              events: [start, end]\n            };\n          }\n\n          return null;\n        }), filter(isPresent)).subscribe(subscriber);\n      });\n    }\n\n  };\n\n  TuiSwipeService.ɵfac = function TuiSwipeService_Factory(t) {\n    return new (t || TuiSwipeService)(ɵngcc0.ɵɵinject(ElementRef), ɵngcc0.ɵɵinject(TUI_SWIPE_OPTIONS), ɵngcc0.ɵɵinject(DOCUMENT));\n  };\n\n  TuiSwipeService.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: TuiSwipeService,\n    factory: function (t) {\n      return TuiSwipeService.ɵfac(t);\n    }\n  });\n  TuiSwipeService = __decorate([__param(0, Inject(ElementRef)), __param(1, Inject(TUI_SWIPE_OPTIONS)), __param(2, Inject(DOCUMENT))], TuiSwipeService);\n  return TuiSwipeService;\n})();\nconst TOUCH_SENSITIVITY = 0.01; // @dynamic\n\nlet TuiZoomService = /*#__PURE__*/(() => {\n  let TuiZoomService = class TuiZoomService extends Observable {\n    constructor({\n      nativeElement\n    }, {\n      wheelSensitivity\n    }) {\n      super(subscriber => {\n        merge(typedFromEvent(nativeElement, 'touchstart', {\n          passive: true\n        }).pipe(filter(({\n          touches\n        }) => touches.length > 1), switchMap(startEvent => typedFromEvent(nativeElement, 'touchmove', {\n          passive: true\n        }).pipe(takeUntil(typedFromEvent(nativeElement, 'touchend')), scan((prev, event) => {\n          const distance = distanceBetweenTouches(event);\n          return {\n            event,\n            distance,\n            delta: (distance - prev.distance) * TOUCH_SENSITIVITY\n          };\n        }, {\n          event: startEvent,\n          distance: distanceBetweenTouches(startEvent),\n          delta: 0\n        }), map(({\n          event,\n          delta\n        }) => {\n          event.preventDefault();\n          const clientX = (event.touches[0].clientX + event.touches[1].clientX) / 2;\n          const clientY = (event.touches[0].clientY + event.touches[1].clientY) / 2;\n          return {\n            clientX,\n            clientY,\n            delta,\n            event\n          };\n        })))), typedFromEvent(nativeElement, 'wheel', {\n          passive: false\n        }).pipe(preventDefault(), map(wheel => ({\n          clientX: wheel.clientX,\n          clientY: wheel.clientY,\n          delta: -wheel.deltaY * wheelSensitivity,\n          event: wheel\n        })))).subscribe(subscriber);\n      });\n    }\n\n  };\n\n  TuiZoomService.ɵfac = function TuiZoomService_Factory(t) {\n    return new (t || TuiZoomService)(ɵngcc0.ɵɵinject(ElementRef), ɵngcc0.ɵɵinject(TUI_ZOOM_OPTIONS));\n  };\n\n  TuiZoomService.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: TuiZoomService,\n    factory: function (t) {\n      return TuiZoomService.ɵfac(t);\n    }\n  });\n  TuiZoomService = __decorate([__param(0, Inject(ElementRef)), __param(1, Inject(TUI_ZOOM_OPTIONS))], TuiZoomService);\n  return TuiZoomService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { TuiDestroyService, TuiDirectiveStylesService, TuiFocusVisibleService, TuiHoveredService, TuiIdService, TuiObscuredService, TuiPanService, TuiParentsScrollService, TuiResizeService, TuiScrollService, TuiStaticRequestService, TuiSwipeService, TuiZoomService }; //# sourceMappingURL=taiga-ui-cdk-services.js.map","map":null,"metadata":{},"sourceType":"module"}