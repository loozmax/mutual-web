{"ast":null,"code":"import { tuiAssert } from '@taiga-ui/cdk/classes';\nimport { TuiPureException } from '@taiga-ui/cdk/exceptions';\n/**\n * Decorator for checking input values for undefined. You can also pass\n * optional assertion to check input against.\n *\n * See {@link createPropDecorator} for more details.\n *\n * CAUTION: This decorator overwrites other getters and setters.\n */\n\nfunction tuiDefaultProp(assertion, ...args) {\n  return (target, key) => {\n    const {\n      name\n    } = target.constructor;\n    const errorGetDefaultMessage = errorGetDefault(key, name);\n    const errorSetDefaultMessage = errorSetDefault(key, name);\n    Object.defineProperty(target, key, {\n      get() {\n        tuiAssert.assert(false, errorGetDefaultMessage);\n        return undefined;\n      },\n\n      set(initialValue) {\n        const isValid = initialValue !== undefined;\n        const errorMessage = errorSetDefaultInitial(key, name);\n        let currentValue = initialValue;\n        tuiAssert.assert(isValid, errorMessage);\n\n        if (isValid && assertion) {\n          tuiAssert.assert(assertion.call(this, initialValue), `${String(key)} in ${name} received:`, initialValue, ...args);\n        }\n\n        Object.defineProperty(this, key, {\n          get() {\n            return currentValue;\n          },\n\n          set(value) {\n            const isValid = value !== undefined;\n            const backupValue = initialValue;\n            tuiAssert.assert(isValid, errorSetDefaultMessage, String(backupValue));\n\n            if (isValid && assertion) {\n              tuiAssert.assert(assertion.call(this, value), `${String(key)} in ${name} received:`, value, ...args);\n            }\n\n            currentValue = isValid ? value : backupValue;\n          }\n\n        });\n      }\n\n    });\n  };\n}\n\nfunction errorGetDefault(key, component) {\n  return `Default value for ${String(key)} was not provided in ${component}, error in Taiga UI Angular Kit`;\n}\n\nfunction errorSetDefault(key, component) {\n  return `Undefined was passed as ${String(key)} to ${component}, which is invalid input, using default value:`;\n}\n\nfunction errorSetDefaultInitial(key, component) {\n  return `Undefined was passed as default value for ${String(key)} to ${component}, error in Taiga UI Angular Kit`;\n}\n/**\n * Implements lazy initialization for getter or memoization of a function call similar to pure {@link: Pipe}.\n * Replaces getter with its calculated value upon first call or keeps track of last call arguments and returned\n * value for function, skipping calculation when arguments are strictly the same.\n *\n * @throws error if used not on getter or function\n *\n * CAUTION: `this` is not available inside such functions/getters, they must be pure.\n */\n\n\nfunction tuiPure(_target, propertyKey, {\n  get,\n  enumerable,\n  value\n}) {\n  if (get) {\n    return {\n      enumerable,\n\n      get() {\n        const value = get.call(this);\n        Object.defineProperty(this, propertyKey, {\n          enumerable,\n          value\n        });\n        return value;\n      }\n\n    };\n  }\n\n  if (typeof value !== 'function') {\n    throw new TuiPureException();\n  }\n\n  const original = value;\n  return {\n    enumerable,\n\n    get() {\n      let previousArgs = [];\n      let originalFnWasCalledLeastAtOnce = false;\n      let pureValue;\n\n      const patched = (...args) => {\n        const isPure = originalFnWasCalledLeastAtOnce && previousArgs.length === args.length && args.every((arg, index) => arg === previousArgs[index]);\n\n        if (isPure) {\n          return pureValue;\n        }\n\n        previousArgs = args;\n        pureValue = original.apply(this, args);\n        originalFnWasCalledLeastAtOnce = true;\n        return pureValue;\n      };\n\n      Object.defineProperty(this, propertyKey, {\n        value: patched\n      });\n      return patched;\n    }\n\n  };\n}\n/**\n * Decorator for checking input setter values against a custom assertion which\n * takes value passed to input setter and component instance as arguments.\n * It specifically checks for undefined values and prevents calls to the\n * original setter in this case.\n */\n\n\nfunction tuiRequiredSetter(assertion, ...args) {\n  return (target, key, {\n    configurable,\n    enumerable,\n    get,\n    set\n  }) => {\n    const {\n      name\n    } = target.constructor;\n    return {\n      configurable,\n      enumerable,\n      get,\n\n      set(value) {\n        if (value !== undefined && assertion) {\n          tuiAssert.assert(assertion.call(this, value), `${String(key)} in ${name} received:`, value, ...args);\n        }\n\n        if (!set || value === undefined) {\n          tuiAssert.assert(value !== undefined, errorSet(key, name));\n          return;\n        }\n\n        set.call(this, value);\n      }\n\n    };\n  };\n}\n\nfunction errorSet(key, component) {\n  return `Undefined was passed as ${String(key)} to ${component}, setter will not be called`;\n}\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { tuiDefaultProp, tuiPure, tuiRequiredSetter }; //# sourceMappingURL=taiga-ui-cdk-decorators.js.map","map":null,"metadata":{},"sourceType":"module"}