{"ast":null,"code":"import { __decorate, __param } from 'tslib';\nimport { Optional, Self, Inject, NgZone, ElementRef, Renderer2, Input, Directive, NgModule } from '@angular/core';\nimport { ANIMATION_FRAME } from '@ng-web-apis/common';\nimport { POLLING_TIME } from '@taiga-ui/cdk/constants';\nimport { TUI_FOCUSABLE_ITEM_ACCESSOR, TUI_IS_IOS } from '@taiga-ui/cdk/tokens';\nimport { setNativeFocused } from '@taiga-ui/cdk/utils/focus';\nimport { race, timer, Observable } from 'rxjs';\nimport { throttleTime, map, skipWhile, take } from 'rxjs/operators';\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from 'rxjs';\nconst TIMEOUT = 1000;\nconst NG_ANIMATION_SELECTOR = '.ng-animating'; // TODO: in 3.0 change input name to tuiAutoFocus and handle empty string\n// TODO: refactor on this whole thing in 3.0\n\nlet TuiAutoFocusDirective = /*#__PURE__*/(() => {\n  let TuiAutoFocusDirective = class TuiAutoFocusDirective {\n    constructor(tuiFocusableComponent, isIos, animationFrame$, ngZone, elementRef, renderer) {\n      this.tuiFocusableComponent = tuiFocusableComponent;\n      this.isIos = isIos;\n      this.animationFrame$ = animationFrame$;\n      this.ngZone = ngZone;\n      this.elementRef = elementRef;\n      this.renderer = renderer;\n      this.autoFocus = true;\n    }\n\n    ngAfterViewInit() {\n      if (!this.autoFocus) {\n        return;\n      }\n\n      if (this.isTextFieldElement) {\n        if (this.isIos) {\n          this.ngZone.runOutsideAngular(() => this.iosWebkitAutofocus());\n        } else {\n          race(timer(TIMEOUT), this.animationFrame$.pipe(throttleTime(POLLING_TIME), map(() => this.element.closest(NG_ANIMATION_SELECTOR)), skipWhile(Boolean), take(1))).subscribe(() => setNativeFocused(this.element));\n        }\n\n        return;\n      }\n\n      setNativeFocused(this.element);\n    }\n\n    get element() {\n      var _a;\n\n      return ((_a = this.tuiFocusableComponent) === null || _a === void 0 ? void 0 : _a.nativeFocusableElement) || this.elementRef.nativeElement;\n    }\n\n    get isTextFieldElement() {\n      return this.element.matches('input, textarea');\n    }\n\n    iosWebkitAutofocus() {\n      var _a;\n\n      const fakeInput = this.renderer.createElement('input');\n      fakeInput.style.position = 'absolute';\n      fakeInput.style.opacity = '0';\n      fakeInput.style.height = '0';\n\n      const blurHandler = () => setNativeFocused(fakeInput);\n\n      const focusHandler = () => {\n        setTimeout(() => {\n          setNativeFocused(this.element);\n          /**\n           * @note:\n           * We can't remove the element immediately, because it breaks flow\n           */\n\n          setTimeout(() => {\n            fakeInput.removeEventListener('blur', blurHandler);\n            fakeInput.removeEventListener('focus', focusHandler);\n            fakeInput.remove();\n          });\n        });\n      };\n      /**\n       * @note: ping-pong eager strategy hack\n       * After creating an element and bringing it into DOM,\n       * the browser automatically focuses on the invisible element.\n       * And then, after focus is triggered, we try to focus on target element, and if we managed to refocus,\n       * then we try to focus again on an invisible element, so that the keyboard slowly appears.\n       * This ping pong allows the keyboard to not overlap the modal window.\n       */\n\n\n      fakeInput.addEventListener('blur', blurHandler, {\n        once: true\n      });\n      fakeInput.addEventListener('focus', focusHandler);\n      (_a = this.element.parentElement) === null || _a === void 0 ? void 0 : _a.appendChild(fakeInput);\n      setNativeFocused(fakeInput);\n    }\n\n  };\n\n  TuiAutoFocusDirective.ɵfac = function TuiAutoFocusDirective_Factory(t) {\n    return new (t || TuiAutoFocusDirective)(ɵngcc0.ɵɵdirectiveInject(TUI_FOCUSABLE_ITEM_ACCESSOR, 10), ɵngcc0.ɵɵdirectiveInject(TUI_IS_IOS), ɵngcc0.ɵɵdirectiveInject(ANIMATION_FRAME), ɵngcc0.ɵɵdirectiveInject(NgZone), ɵngcc0.ɵɵdirectiveInject(ElementRef), ɵngcc0.ɵɵdirectiveInject(Renderer2));\n  };\n\n  TuiAutoFocusDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: TuiAutoFocusDirective,\n    selectors: [[\"\", \"tuiAutoFocus\", \"\"]],\n    inputs: {\n      autoFocus: \"autoFocus\"\n    }\n  });\n\n  __decorate([Input()], TuiAutoFocusDirective.prototype, \"autoFocus\", void 0);\n\n  TuiAutoFocusDirective = __decorate([__param(0, Optional()), __param(0, Self()), __param(0, Inject(TUI_FOCUSABLE_ITEM_ACCESSOR)), __param(1, Inject(TUI_IS_IOS)), __param(2, Inject(ANIMATION_FRAME)), __param(3, Inject(NgZone)), __param(4, Inject(ElementRef)), __param(5, Inject(Renderer2))], TuiAutoFocusDirective);\n  return TuiAutoFocusDirective;\n})();\nlet TuiAutoFocusModule = /*#__PURE__*/(() => {\n  let TuiAutoFocusModule = class TuiAutoFocusModule {};\n\n  TuiAutoFocusModule.ɵfac = function TuiAutoFocusModule_Factory(t) {\n    return new (t || TuiAutoFocusModule)();\n  };\n\n  TuiAutoFocusModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: TuiAutoFocusModule\n  });\n  TuiAutoFocusModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({});\n  return TuiAutoFocusModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(TuiAutoFocusModule, {\n    declarations: [TuiAutoFocusDirective],\n    exports: [TuiAutoFocusDirective]\n  });\n})();\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { TuiAutoFocusDirective, TuiAutoFocusModule }; //# sourceMappingURL=taiga-ui-cdk-directives-auto-focus.js.map","map":null,"metadata":{},"sourceType":"module"}