{"ast":null,"code":"import { svgNodeFilter, CHAR_NO_BREAK_SPACE, CHAR_ZERO_WIDTH_SPACE } from '@taiga-ui/cdk';\n/**\n * Creates a cloned range with its boundaries set at word boundaries\n *\n * @param currentRange a range to clone\n * @return modified range\n */\n\nfunction getWordRange(currentRange) {\n  const range = currentRange.cloneRange();\n  const {\n    startContainer,\n    startOffset,\n    endContainer,\n    endOffset\n  } = range;\n  const {\n    ownerDocument\n  } = startContainer;\n\n  if (!ownerDocument) {\n    return range;\n  }\n\n  const treeWalker = ownerDocument.createTreeWalker(ownerDocument.body, NodeFilter.SHOW_TEXT, svgNodeFilter, false);\n  treeWalker.currentNode = startContainer;\n\n  do {\n    const container = treeWalker.currentNode;\n    const textContent = container.textContent || '';\n    const content = container === startContainer ? textContent.substr(0, startOffset + 1) : textContent;\n    const offset = Math.max(content.lastIndexOf(' '), content.lastIndexOf(CHAR_NO_BREAK_SPACE), content.lastIndexOf(CHAR_ZERO_WIDTH_SPACE)) + 1;\n    range.setStart(container, 0);\n\n    if (offset) {\n      range.setStart(container, offset);\n      break;\n    }\n  } while (treeWalker.previousNode());\n\n  treeWalker.currentNode = endContainer;\n\n  do {\n    const container = treeWalker.currentNode;\n    const textContent = container.textContent || '';\n    const content = container === endContainer ? textContent.substr(endOffset + 1) : textContent;\n    const offset = [content.indexOf(' '), content.indexOf(CHAR_NO_BREAK_SPACE), content.indexOf(CHAR_ZERO_WIDTH_SPACE)].reduce((result, item) => result === -1 || item === -1 ? Math.max(result, item) : Math.min(result, item), -1);\n    range.setEnd(container, textContent.length);\n\n    if (offset !== -1) {\n      range.setEnd(container, offset + textContent.length - content.length);\n      break;\n    }\n  } while (treeWalker.nextNode());\n\n  return range;\n}\n\nfunction scrollToElement(element, container) {\n  const scrolledWidth = container.offsetWidth + container.scrollLeft;\n  const elementWidth = element.offsetWidth;\n  const elementX = container.scrollLeft + element.getBoundingClientRect().left - container.getBoundingClientRect().left;\n  const elementDidNotFitRight = elementX + elementWidth > scrolledWidth;\n  const elementDidNotFitLeft = container.scrollLeft > elementX;\n  const deltaXRight = elementX + elementWidth - scrolledWidth;\n  const deltaXLeft = elementX - container.scrollLeft;\n\n  if (elementDidNotFitRight) {\n    container.scrollLeft += deltaXRight;\n  }\n\n  if (elementDidNotFitLeft) {\n    container.scrollLeft += deltaXLeft;\n  }\n}\n/**\n * Range.setStart/set-end, except it uses offset in characters only\n */\n\n\nfunction setRangeOffset(range, node, offset, method) {\n  const {\n    ownerDocument\n  } = node;\n\n  if (!ownerDocument) {\n    return;\n  }\n\n  const treeWalker = ownerDocument.createTreeWalker(node, NodeFilter.SHOW_TEXT, svgNodeFilter, false);\n  treeWalker.currentNode = node;\n\n  while (treeWalker.nextNode()) {\n    if (treeWalker.currentNode.nodeType === Node.TEXT_NODE) {\n      const length = treeWalker.currentNode.nodeValue ? treeWalker.currentNode.nodeValue.length : 0;\n\n      if (offset > length) {\n        offset -= length;\n      } else {\n        range[method](treeWalker.currentNode, offset);\n      }\n    }\n  }\n}\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { getWordRange, scrollToElement, setRangeOffset }; //# sourceMappingURL=taiga-ui-kit-utils-dom.js.map","map":null,"metadata":{},"sourceType":"module"}